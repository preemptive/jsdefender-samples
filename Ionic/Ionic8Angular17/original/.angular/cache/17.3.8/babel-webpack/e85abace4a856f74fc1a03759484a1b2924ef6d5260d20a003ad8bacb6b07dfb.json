{"ast":null,"code":"import { __decorate, __param, __awaiter } from 'tslib';\nimport { HostListener, Injector, ElementRef, Directive, Inject, NgZone, ɵɵdefineInjectable, ɵɵinject, Injectable, Optional, ChangeDetectorRef, Component, ChangeDetectionStrategy, InjectionToken, ApplicationRef, EventEmitter, ViewContainerRef, ComponentFactoryResolver, Attribute, SkipSelf, Output, ViewChild, ContentChild, TemplateRef, IterableDiffers, APP_INITIALIZER, NgModule } from '@angular/core';\nimport { NgControl, NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { DOCUMENT, Location, LocationStrategy, CommonModule } from '@angular/common';\nimport { NavigationStart, UrlSerializer, Router, PRIMARY_OUTLET, ActivatedRoute, ChildrenOutletContexts, RouterLink } from '@angular/router';\nimport { isPlatform, getPlatforms, LIFECYCLE_WILL_ENTER, LIFECYCLE_DID_ENTER, LIFECYCLE_WILL_LEAVE, LIFECYCLE_DID_LEAVE, LIFECYCLE_WILL_UNLOAD, actionSheetController, alertController, loadingController, menuController, pickerController, modalController, popoverController, toastController, createAnimation, getTimeGivenProgression, createGesture } from '@ionic/core';\nexport { IonicSafeString, createAnimation, getPlatforms, iosTransitionAnimation, isPlatform, mdTransitionAnimation } from '@ionic/core';\nimport { Subject, fromEvent, BehaviorSubject } from 'rxjs';\nimport { filter, switchMap, distinctUntilChanged } from 'rxjs/operators';\nimport { applyPolyfills, defineCustomElements } from '@ionic/core/loader';\nconst raf = h => {\n  if (typeof __zone_symbol__requestAnimationFrame === 'function') {\n    return __zone_symbol__requestAnimationFrame(h);\n  }\n  if (typeof requestAnimationFrame === 'function') {\n    return requestAnimationFrame(h);\n  }\n  return setTimeout(h);\n};\nlet ValueAccessor = /*#__PURE__*/(() => {\n  class ValueAccessor {\n    constructor(injector, el) {\n      this.injector = injector;\n      this.el = el;\n      this.onChange = () => {};\n      this.onTouched = () => {};\n    }\n    writeValue(value) {\n      /**\n       * TODO for Ionic 6:\n       * Change `value == null ? '' : value;`\n       * to `value`. This was a fix for IE9, but IE9\n       * is no longer supported; however, this change\n       * is potentially a breaking change\n       */\n      this.el.nativeElement.value = this.lastValue = value == null ? '' : value;\n      setIonicClasses(this.el);\n    }\n    handleChangeEvent(el, value) {\n      if (el === this.el.nativeElement) {\n        if (value !== this.lastValue) {\n          this.lastValue = value;\n          this.onChange(value);\n        }\n        setIonicClasses(this.el);\n      }\n    }\n    _handleBlurEvent(el) {\n      if (el === this.el.nativeElement) {\n        this.onTouched();\n        setIonicClasses(this.el);\n      }\n    }\n    registerOnChange(fn) {\n      this.onChange = fn;\n    }\n    registerOnTouched(fn) {\n      this.onTouched = fn;\n    }\n    setDisabledState(isDisabled) {\n      this.el.nativeElement.disabled = isDisabled;\n    }\n    ngOnDestroy() {\n      if (this.statusChanges) {\n        this.statusChanges.unsubscribe();\n      }\n    }\n    ngAfterViewInit() {\n      let ngControl;\n      try {\n        ngControl = this.injector.get(NgControl);\n      } catch ( /* No FormControl or ngModel binding */_a) {/* No FormControl or ngModel binding */}\n      if (!ngControl) {\n        return;\n      }\n      // Listen for changes in validity, disabled, or pending states\n      if (ngControl.statusChanges) {\n        this.statusChanges = ngControl.statusChanges.subscribe(() => setIonicClasses(this.el));\n      }\n      /**\n       * TODO Remove this in favor of https://github.com/angular/angular/issues/10887\n       * whenever it is implemented. Currently, Ionic's form status classes\n       * do not react to changes when developers manually call\n       * Angular form control methods such as markAsTouched.\n       * This results in Ionic's form status classes being out\n       * of sync with the ng form status classes.\n       * This patches the methods to manually sync\n       * the classes until this feature is implemented in Angular.\n       */\n      const formControl = ngControl.control;\n      if (formControl) {\n        const methodsToPatch = ['markAsTouched', 'markAllAsTouched', 'markAsUntouched', 'markAsDirty', 'markAsPristine'];\n        methodsToPatch.forEach(method => {\n          if (formControl[method]) {\n            const oldFn = formControl[method].bind(formControl);\n            formControl[method] = (...params) => {\n              oldFn(...params);\n              setIonicClasses(this.el);\n            };\n          }\n        });\n      }\n    }\n  }\n  __decorate([HostListener('ionBlur', ['$event.target'])], ValueAccessor.prototype, \"_handleBlurEvent\", null);\n  return ValueAccessor;\n})();\nconst setIonicClasses = element => {\n  raf(() => {\n    const input = element.nativeElement;\n    const classes = getClasses(input);\n    setClasses(input, classes);\n    const item = input.closest('ion-item');\n    if (item) {\n      setClasses(item, classes);\n    }\n  });\n};\nconst getClasses = element => {\n  const classList = element.classList;\n  const classes = [];\n  for (let i = 0; i < classList.length; i++) {\n    const item = classList.item(i);\n    if (item !== null && startsWith(item, 'ng-')) {\n      classes.push(`ion-${item.substr(3)}`);\n    }\n  }\n  return classes;\n};\nconst ɵ0 = getClasses;\nconst setClasses = (element, classes) => {\n  const classList = element.classList;\n  ['ion-valid', 'ion-invalid', 'ion-touched', 'ion-untouched', 'ion-dirty', 'ion-pristine'].forEach(c => classList.remove(c));\n  classes.forEach(c => classList.add(c));\n};\nconst ɵ1 = setClasses;\nconst startsWith = (input, search) => {\n  return input.substr(0, search.length) === search;\n};\nconst ɵ2 = startsWith;\nvar BooleanValueAccessor_1;\nlet BooleanValueAccessor = BooleanValueAccessor_1 = class BooleanValueAccessor extends ValueAccessor {\n  constructor(injector, el) {\n    super(injector, el);\n  }\n  writeValue(value) {\n    this.el.nativeElement.checked = this.lastValue = value == null ? false : value;\n    setIonicClasses(this.el);\n  }\n  _handleIonChange(el) {\n    this.handleChangeEvent(el, el.checked);\n  }\n};\nBooleanValueAccessor.ctorParameters = () => [{\n  type: Injector\n}, {\n  type: ElementRef\n}];\n__decorate([HostListener('ionChange', ['$event.target'])], BooleanValueAccessor.prototype, \"_handleIonChange\", null);\nBooleanValueAccessor = BooleanValueAccessor_1 = __decorate([Directive({\n  /* tslint:disable-next-line:directive-selector */\n  selector: 'ion-checkbox,ion-toggle',\n  providers: [{\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: BooleanValueAccessor_1,\n    multi: true\n  }]\n})], BooleanValueAccessor);\nvar NumericValueAccessor_1;\nlet NumericValueAccessor = NumericValueAccessor_1 = class NumericValueAccessor extends ValueAccessor {\n  constructor(injector, el) {\n    super(injector, el);\n  }\n  _handleIonChange(el) {\n    this.handleChangeEvent(el, el.value);\n  }\n  registerOnChange(fn) {\n    super.registerOnChange(value => {\n      fn(value === '' ? null : parseFloat(value));\n    });\n  }\n};\nNumericValueAccessor.ctorParameters = () => [{\n  type: Injector\n}, {\n  type: ElementRef\n}];\n__decorate([HostListener('ionChange', ['$event.target'])], NumericValueAccessor.prototype, \"_handleIonChange\", null);\nNumericValueAccessor = NumericValueAccessor_1 = __decorate([Directive({\n  /* tslint:disable-next-line:directive-selector */\n  selector: 'ion-input[type=number]',\n  providers: [{\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: NumericValueAccessor_1,\n    multi: true\n  }]\n})], NumericValueAccessor);\nvar RadioValueAccessor_1;\nlet RadioValueAccessor = RadioValueAccessor_1 = class RadioValueAccessor extends ValueAccessor {\n  constructor(injector, el) {\n    super(injector, el);\n  }\n  _handleIonSelect(el) {\n    this.handleChangeEvent(el, el.checked);\n  }\n};\nRadioValueAccessor.ctorParameters = () => [{\n  type: Injector\n}, {\n  type: ElementRef\n}];\n__decorate([HostListener('ionSelect', ['$event.target'])], RadioValueAccessor.prototype, \"_handleIonSelect\", null);\nRadioValueAccessor = RadioValueAccessor_1 = __decorate([Directive({\n  /* tslint:disable-next-line:directive-selector */\n  selector: 'ion-radio',\n  providers: [{\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: RadioValueAccessor_1,\n    multi: true\n  }]\n})], RadioValueAccessor);\nvar SelectValueAccessor_1;\nlet SelectValueAccessor = SelectValueAccessor_1 = class SelectValueAccessor extends ValueAccessor {\n  constructor(injector, el) {\n    super(injector, el);\n  }\n  _handleChangeEvent(el) {\n    this.handleChangeEvent(el, el.value);\n  }\n};\nSelectValueAccessor.ctorParameters = () => [{\n  type: Injector\n}, {\n  type: ElementRef\n}];\n__decorate([HostListener('ionChange', ['$event.target'])], SelectValueAccessor.prototype, \"_handleChangeEvent\", null);\nSelectValueAccessor = SelectValueAccessor_1 = __decorate([Directive({\n  /* tslint:disable-next-line:directive-selector */\n  selector: 'ion-range, ion-select, ion-radio-group, ion-segment, ion-datetime',\n  providers: [{\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: SelectValueAccessor_1,\n    multi: true\n  }]\n})], SelectValueAccessor);\nvar TextValueAccessor_1;\nlet TextValueAccessor = TextValueAccessor_1 = class TextValueAccessor extends ValueAccessor {\n  constructor(injector, el) {\n    super(injector, el);\n  }\n  _handleInputEvent(el) {\n    this.handleChangeEvent(el, el.value);\n  }\n};\nTextValueAccessor.ctorParameters = () => [{\n  type: Injector\n}, {\n  type: ElementRef\n}];\n__decorate([HostListener('ionChange', ['$event.target'])], TextValueAccessor.prototype, \"_handleInputEvent\", null);\nTextValueAccessor = TextValueAccessor_1 = __decorate([Directive({\n  /* tslint:disable-next-line:directive-selector */\n  selector: 'ion-input:not([type=number]),ion-textarea,ion-searchbar',\n  providers: [{\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: TextValueAccessor_1,\n    multi: true\n  }]\n})], TextValueAccessor);\nlet Platform = class Platform {\n  constructor(doc, zone) {\n    this.doc = doc;\n    /**\n     * @hidden\n     */\n    this.backButton = new Subject();\n    /**\n     * The keyboardDidShow event emits when the\n     * on-screen keyboard is presented.\n     */\n    this.keyboardDidShow = new Subject();\n    /**\n     * The keyboardDidHide event emits when the\n     * on-screen keyboard is hidden.\n     */\n    this.keyboardDidHide = new Subject();\n    /**\n     * The pause event emits when the native platform puts the application\n     * into the background, typically when the user switches to a different\n     * application. This event would emit when a Cordova app is put into\n     * the background, however, it would not fire on a standard web browser.\n     */\n    this.pause = new Subject();\n    /**\n     * The resume event emits when the native platform pulls the application\n     * out from the background. This event would emit when a Cordova app comes\n     * out from the background, however, it would not fire on a standard web browser.\n     */\n    this.resume = new Subject();\n    /**\n     * The resize event emits when the browser window has changed dimensions. This\n     * could be from a browser window being physically resized, or from a device\n     * changing orientation.\n     */\n    this.resize = new Subject();\n    zone.run(() => {\n      this.win = doc.defaultView;\n      this.backButton.subscribeWithPriority = function (priority, callback) {\n        return this.subscribe(ev => {\n          return ev.register(priority, processNextHandler => zone.run(() => callback(processNextHandler)));\n        });\n      };\n      proxyEvent(this.pause, doc, 'pause');\n      proxyEvent(this.resume, doc, 'resume');\n      proxyEvent(this.backButton, doc, 'ionBackButton');\n      proxyEvent(this.resize, this.win, 'resize');\n      proxyEvent(this.keyboardDidShow, this.win, 'ionKeyboardDidShow');\n      proxyEvent(this.keyboardDidHide, this.win, 'ionKeyboardDidHide');\n      let readyResolve;\n      this._readyPromise = new Promise(res => {\n        readyResolve = res;\n      });\n      if (this.win && this.win['cordova']) {\n        doc.addEventListener('deviceready', () => {\n          readyResolve('cordova');\n        }, {\n          once: true\n        });\n      } else {\n        readyResolve('dom');\n      }\n    });\n  }\n  /**\n   * @returns returns true/false based on platform.\n   * @description\n   * Depending on the platform the user is on, `is(platformName)` will\n   * return `true` or `false`. Note that the same app can return `true`\n   * for more than one platform name. For example, an app running from\n   * an iPad would return `true` for the platform names: `mobile`,\n   * `ios`, `ipad`, and `tablet`. Additionally, if the app was running\n   * from Cordova then `cordova` would be true, and if it was running\n   * from a web browser on the iPad then `mobileweb` would be `true`.\n   *\n   * ```\n   * import { Platform } from 'ionic-angular';\n   *\n   * @Component({...})\n   * export MyPage {\n   *   constructor(public platform: Platform) {\n   *     if (this.platform.is('ios')) {\n   *       // This will only print when on iOS\n   *       console.log('I am an iOS device!');\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * | Platform Name   | Description                        |\n   * |-----------------|------------------------------------|\n   * | android         | on a device running Android.       |\n   * | cordova         | on a device running Cordova.       |\n   * | ios             | on a device running iOS.           |\n   * | ipad            | on an iPad device.                 |\n   * | iphone          | on an iPhone device.               |\n   * | phablet         | on a phablet device.               |\n   * | tablet          | on a tablet device.                |\n   * | electron        | in Electron on a desktop device.   |\n   * | pwa             | as a PWA app.                      |\n   * | mobile          | on a mobile device.                |\n   * | mobileweb       | on a mobile device in a browser.   |\n   * | desktop         | on a desktop device.               |\n   * | hybrid          | is a cordova or capacitor app.     |\n   *\n   */\n  is(platformName) {\n    return isPlatform(this.win, platformName);\n  }\n  /**\n   * @returns the array of platforms\n   * @description\n   * Depending on what device you are on, `platforms` can return multiple values.\n   * Each possible value is a hierarchy of platforms. For example, on an iPhone,\n   * it would return `mobile`, `ios`, and `iphone`.\n   *\n   * ```\n   * import { Platform } from 'ionic-angular';\n   *\n   * @Component({...})\n   * export MyPage {\n   *   constructor(public platform: Platform) {\n   *     // This will print an array of the current platforms\n   *     console.log(this.platform.platforms());\n   *   }\n   * }\n   * ```\n   */\n  platforms() {\n    return getPlatforms(this.win);\n  }\n  /**\n   * Returns a promise when the platform is ready and native functionality\n   * can be called. If the app is running from within a web browser, then\n   * the promise will resolve when the DOM is ready. When the app is running\n   * from an application engine such as Cordova, then the promise will\n   * resolve when Cordova triggers the `deviceready` event.\n   *\n   * The resolved value is the `readySource`, which states which platform\n   * ready was used. For example, when Cordova is ready, the resolved ready\n   * source is `cordova`. The default ready source value will be `dom`. The\n   * `readySource` is useful if different logic should run depending on the\n   * platform the app is running from. For example, only Cordova can execute\n   * the status bar plugin, so the web should not run status bar plugin logic.\n   *\n   * ```\n   * import { Component } from '@angular/core';\n   * import { Platform } from 'ionic-angular';\n   *\n   * @Component({...})\n   * export MyApp {\n   *   constructor(public platform: Platform) {\n   *     this.platform.ready().then((readySource) => {\n   *       console.log('Platform ready from', readySource);\n   *       // Platform now ready, execute any required native code\n   *     });\n   *   }\n   * }\n   * ```\n   */\n  ready() {\n    return this._readyPromise;\n  }\n  /**\n   * Returns if this app is using right-to-left language direction or not.\n   * We recommend the app's `index.html` file already has the correct `dir`\n   * attribute value set, such as `<html dir=\"ltr\">` or `<html dir=\"rtl\">`.\n   * [W3C: Structural markup and right-to-left text in HTML](http://www.w3.org/International/questions/qa-html-dir)\n   */\n  get isRTL() {\n    return this.doc.dir === 'rtl';\n  }\n  /**\n   * Get the query string parameter\n   */\n  getQueryParam(key) {\n    return readQueryParam(this.win.location.href, key);\n  }\n  /**\n   * Returns `true` if the app is in landscape mode.\n   */\n  isLandscape() {\n    return !this.isPortrait();\n  }\n  /**\n   * Returns `true` if the app is in portait mode.\n   */\n  isPortrait() {\n    return this.win.matchMedia && this.win.matchMedia('(orientation: portrait)').matches;\n  }\n  testUserAgent(expression) {\n    const nav = this.win.navigator;\n    return !!(nav && nav.userAgent && nav.userAgent.indexOf(expression) >= 0);\n  }\n  /**\n   * Get the current url.\n   */\n  url() {\n    return this.win.location.href;\n  }\n  /**\n   * Gets the width of the platform's viewport using `window.innerWidth`.\n   */\n  width() {\n    return this.win.innerWidth;\n  }\n  /**\n   * Gets the height of the platform's viewport using `window.innerHeight`.\n   */\n  height() {\n    return this.win.innerHeight;\n  }\n};\nPlatform.ngInjectableDef = ɵɵdefineInjectable({\n  factory: function Platform_Factory() {\n    return new Platform(ɵɵinject(DOCUMENT), ɵɵinject(NgZone));\n  },\n  token: Platform,\n  providedIn: \"root\"\n});\nPlatform = __decorate([Injectable({\n  providedIn: 'root'\n}), __param(0, Inject(DOCUMENT))], Platform);\nconst readQueryParam = (url, key) => {\n  key = key.replace(/[\\[]/, '\\\\[').replace(/[\\]]/, '\\\\]');\n  const regex = new RegExp('[\\\\?&]' + key + '=([^&#]*)');\n  const results = regex.exec(url);\n  return results ? decodeURIComponent(results[1].replace(/\\+/g, ' ')) : null;\n};\nconst ɵ0$1 = readQueryParam;\nconst proxyEvent = (emitter, el, eventName) => {\n  if (el) {\n    el.addEventListener(eventName, ev => {\n      // ?? cordova might emit \"null\" events\n      emitter.next(ev != null ? ev.detail : undefined);\n    });\n  }\n};\nconst ɵ1$1 = proxyEvent;\nlet NavController = class NavController {\n  constructor(platform, location, serializer, router) {\n    this.location = location;\n    this.serializer = serializer;\n    this.router = router;\n    this.direction = DEFAULT_DIRECTION;\n    this.animated = DEFAULT_ANIMATED;\n    this.guessDirection = 'forward';\n    this.lastNavId = -1;\n    // Subscribe to router events to detect direction\n    if (router) {\n      router.events.subscribe(ev => {\n        if (ev instanceof NavigationStart) {\n          const id = ev.restoredState ? ev.restoredState.navigationId : ev.id;\n          this.guessDirection = id < this.lastNavId ? 'back' : 'forward';\n          this.guessAnimation = !ev.restoredState ? this.guessDirection : undefined;\n          this.lastNavId = this.guessDirection === 'forward' ? ev.id : id;\n        }\n      });\n    }\n    // Subscribe to backButton events\n    platform.backButton.subscribeWithPriority(0, processNextHandler => {\n      this.pop();\n      processNextHandler();\n    });\n  }\n  /**\n   * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n   * it's equivalent to calling `this.router.navigateByUrl()`, but it's explicit about the **direction** of the transition.\n   *\n   * Going **forward** means that a new page is going to be pushed to the stack of the outlet (ion-router-outlet),\n   * and that it will show a \"forward\" animation by default.\n   *\n   * Navigating forward can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n   *\n   * ```html\n   * <a routerLink=\"/path/to/page\" routerDirection=\"forward\">Link</a>\n   * ```\n   */\n  navigateForward(url, options = {}) {\n    this.setDirection('forward', options.animated, options.animationDirection, options.animation);\n    return this.navigate(url, options);\n  }\n  /**\n   * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n   * it's equivalent to calling:\n   *\n   * ```ts\n   * this.navController.setDirection('back');\n   * this.router.navigateByUrl(path);\n   * ```\n   *\n   * Going **back** means that all the pages in the stack until the navigated page is found will be popped,\n   * and that it will show a \"back\" animation by default.\n   *\n   * Navigating back can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n   *\n   * ```html\n   * <a routerLink=\"/path/to/page\" routerDirection=\"back\">Link</a>\n   * ```\n   */\n  navigateBack(url, options = {}) {\n    this.setDirection('back', options.animated, options.animationDirection, options.animation);\n    return this.navigate(url, options);\n  }\n  /**\n   * This method uses Angular's [Router](https://angular.io/api/router/Router) under the hood,\n   * it's equivalent to calling:\n   *\n   * ```ts\n   * this.navController.setDirection('root');\n   * this.router.navigateByUrl(path);\n   * ```\n   *\n   * Going **root** means that all existing pages in the stack will be removed,\n   * and the navigated page will become the single page in the stack.\n   *\n   * Navigating root can also be triggered in a declarative manner by using the `[routerDirection]` directive:\n   *\n   * ```html\n   * <a routerLink=\"/path/to/page\" routerDirection=\"root\">Link</a>\n   * ```\n   */\n  navigateRoot(url, options = {}) {\n    this.setDirection('root', options.animated, options.animationDirection, options.animation);\n    return this.navigate(url, options);\n  }\n  /**\n   * Same as [Location](https://angular.io/api/common/Location)'s back() method.\n   * It will use the standard `window.history.back()` under the hood, but featuring a `back` animation\n   * by default.\n   */\n  back(options = {\n    animated: true,\n    animationDirection: 'back'\n  }) {\n    this.setDirection('back', options.animated, options.animationDirection, options.animation);\n    return this.location.back();\n  }\n  /**\n   * This methods goes back in the context of Ionic's stack navigation.\n   *\n   * It recursively finds the top active `ion-router-outlet` and calls `pop()`.\n   * This is the recommended way to go back when you are using `ion-router-outlet`.\n   */\n  pop() {\n    return __awaiter(this, void 0, void 0, function* () {\n      let outlet = this.topOutlet;\n      while (outlet) {\n        if (yield outlet.pop()) {\n          break;\n        } else {\n          outlet = outlet.parentOutlet;\n        }\n      }\n    });\n  }\n  /**\n   * This methods specifies the direction of the next navigation performed by the Angular router.\n   *\n   * `setDirection()` does not trigger any transition, it just sets some flags to be consumed by `ion-router-outlet`.\n   *\n   * It's recommended to use `navigateForward()`, `navigateBack()` and `navigateRoot()` instead of `setDirection()`.\n   */\n  setDirection(direction, animated, animationDirection, animationBuilder) {\n    this.direction = direction;\n    this.animated = getAnimation(direction, animated, animationDirection);\n    this.animationBuilder = animationBuilder;\n  }\n  /**\n   * @internal\n   */\n  setTopOutlet(outlet) {\n    this.topOutlet = outlet;\n  }\n  /**\n   * @internal\n   */\n  consumeTransition() {\n    let direction = 'root';\n    let animation;\n    const animationBuilder = this.animationBuilder;\n    if (this.direction === 'auto') {\n      direction = this.guessDirection;\n      animation = this.guessAnimation;\n    } else {\n      animation = this.animated;\n      direction = this.direction;\n    }\n    this.direction = DEFAULT_DIRECTION;\n    this.animated = DEFAULT_ANIMATED;\n    this.animationBuilder = undefined;\n    return {\n      direction,\n      animation,\n      animationBuilder\n    };\n  }\n  navigate(url, options) {\n    if (Array.isArray(url)) {\n      return this.router.navigate(url, options);\n    } else {\n      /**\n       * navigateByUrl ignores any properties that\n       * would change the url, so things like queryParams\n       * would be ignored unless we create a url tree\n       * More Info: https://github.com/angular/angular/issues/18798\n       */\n      const urlTree = this.serializer.parse(url.toString());\n      if (options.queryParams !== undefined) {\n        urlTree.queryParams = Object.assign({}, options.queryParams);\n      }\n      if (options.fragment !== undefined) {\n        urlTree.fragment = options.fragment;\n      }\n      /**\n       * `navigateByUrl` will still apply `NavigationExtras` properties\n       * that do not modify the url, such as `replaceUrl` which is why\n       * `options` is passed in here.\n       */\n      return this.router.navigateByUrl(urlTree, options);\n    }\n  }\n};\nNavController.ngInjectableDef = ɵɵdefineInjectable({\n  factory: function NavController_Factory() {\n    return new NavController(ɵɵinject(Platform), ɵɵinject(Location), ɵɵinject(UrlSerializer), ɵɵinject(Router, 8));\n  },\n  token: NavController,\n  providedIn: \"root\"\n});\nNavController = __decorate([Injectable({\n  providedIn: 'root'\n}), __param(3, Optional())], NavController);\nconst getAnimation = (direction, animated, animationDirection) => {\n  if (animated === false) {\n    return undefined;\n  }\n  if (animationDirection !== undefined) {\n    return animationDirection;\n  }\n  if (direction === 'forward' || direction === 'back') {\n    return direction;\n  } else if (direction === 'root' && animated === true) {\n    return 'forward';\n  }\n  return undefined;\n};\nconst ɵ0$2 = getAnimation;\nconst DEFAULT_DIRECTION = 'auto';\nconst DEFAULT_ANIMATED = undefined;\n\n/* eslint-disable */\nconst proxyInputs = (Cmp, inputs) => {\n  const Prototype = Cmp.prototype;\n  inputs.forEach(item => {\n    Object.defineProperty(Prototype, item, {\n      get() {\n        return this.el[item];\n      },\n      set(val) {\n        this.z.runOutsideAngular(() => this.el[item] = val);\n      }\n    });\n  });\n};\nconst proxyMethods = (Cmp, methods) => {\n  const Prototype = Cmp.prototype;\n  methods.forEach(methodName => {\n    Prototype[methodName] = function () {\n      const args = arguments;\n      return this.z.runOutsideAngular(() => this.el[methodName].apply(this.el, args));\n    };\n  });\n};\nconst proxyOutputs = (instance, el, events) => {\n  events.forEach(eventName => instance[eventName] = fromEvent(el, eventName));\n};\nfunction ProxyCmp(opts) {\n  const decorator = function (cls) {\n    if (opts.inputs) {\n      proxyInputs(cls, opts.inputs);\n    }\n    if (opts.methods) {\n      proxyMethods(cls, opts.methods);\n    }\n    return cls;\n  };\n  return decorator;\n}\nlet IonApp = /*#__PURE__*/(() => {\n  let IonApp = class IonApp {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonApp = __decorate([Component({\n    selector: \"ion-app\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\"\n  })], IonApp);\n  return IonApp;\n})();\nlet IonAvatar = /*#__PURE__*/(() => {\n  let IonAvatar = class IonAvatar {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonAvatar = __decorate([Component({\n    selector: \"ion-avatar\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\"\n  })], IonAvatar);\n  return IonAvatar;\n})();\nlet IonBackButton = /*#__PURE__*/(() => {\n  let IonBackButton = class IonBackButton {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonBackButton = __decorate([ProxyCmp({\n    inputs: [\"color\", \"defaultHref\", \"disabled\", \"icon\", \"mode\", \"routerAnimation\", \"text\", \"type\"]\n  }), Component({\n    selector: \"ion-back-button\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"color\", \"defaultHref\", \"disabled\", \"icon\", \"mode\", \"routerAnimation\", \"text\", \"type\"]\n  })], IonBackButton);\n  return IonBackButton;\n})();\nlet IonBackdrop = /*#__PURE__*/(() => {\n  let IonBackdrop = class IonBackdrop {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, [\"ionBackdropTap\"]);\n    }\n  };\n  IonBackdrop = __decorate([ProxyCmp({\n    inputs: [\"stopPropagation\", \"tappable\", \"visible\"]\n  }), Component({\n    selector: \"ion-backdrop\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"stopPropagation\", \"tappable\", \"visible\"]\n  })], IonBackdrop);\n  return IonBackdrop;\n})();\nlet IonBadge = /*#__PURE__*/(() => {\n  let IonBadge = class IonBadge {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonBadge = __decorate([ProxyCmp({\n    inputs: [\"color\", \"mode\"]\n  }), Component({\n    selector: \"ion-badge\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"color\", \"mode\"]\n  })], IonBadge);\n  return IonBadge;\n})();\nlet IonButton = /*#__PURE__*/(() => {\n  let IonButton = class IonButton {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, [\"ionFocus\", \"ionBlur\"]);\n    }\n  };\n  IonButton = __decorate([ProxyCmp({\n    inputs: [\"buttonType\", \"color\", \"disabled\", \"download\", \"expand\", \"fill\", \"href\", \"mode\", \"rel\", \"routerAnimation\", \"routerDirection\", \"shape\", \"size\", \"strong\", \"target\", \"type\"]\n  }), Component({\n    selector: \"ion-button\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"buttonType\", \"color\", \"disabled\", \"download\", \"expand\", \"fill\", \"href\", \"mode\", \"rel\", \"routerAnimation\", \"routerDirection\", \"shape\", \"size\", \"strong\", \"target\", \"type\"]\n  })], IonButton);\n  return IonButton;\n})();\nlet IonButtons = /*#__PURE__*/(() => {\n  let IonButtons = class IonButtons {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonButtons = __decorate([ProxyCmp({\n    inputs: [\"collapse\"]\n  }), Component({\n    selector: \"ion-buttons\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"collapse\"]\n  })], IonButtons);\n  return IonButtons;\n})();\nlet IonCard = /*#__PURE__*/(() => {\n  let IonCard = class IonCard {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonCard = __decorate([ProxyCmp({\n    inputs: [\"button\", \"color\", \"disabled\", \"download\", \"href\", \"mode\", \"rel\", \"routerAnimation\", \"routerDirection\", \"target\", \"type\"]\n  }), Component({\n    selector: \"ion-card\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"button\", \"color\", \"disabled\", \"download\", \"href\", \"mode\", \"rel\", \"routerAnimation\", \"routerDirection\", \"target\", \"type\"]\n  })], IonCard);\n  return IonCard;\n})();\nlet IonCardContent = /*#__PURE__*/(() => {\n  let IonCardContent = class IonCardContent {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonCardContent = __decorate([ProxyCmp({\n    inputs: [\"mode\"]\n  }), Component({\n    selector: \"ion-card-content\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"mode\"]\n  })], IonCardContent);\n  return IonCardContent;\n})();\nlet IonCardHeader = /*#__PURE__*/(() => {\n  let IonCardHeader = class IonCardHeader {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonCardHeader = __decorate([ProxyCmp({\n    inputs: [\"color\", \"mode\", \"translucent\"]\n  }), Component({\n    selector: \"ion-card-header\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"color\", \"mode\", \"translucent\"]\n  })], IonCardHeader);\n  return IonCardHeader;\n})();\nlet IonCardSubtitle = /*#__PURE__*/(() => {\n  let IonCardSubtitle = class IonCardSubtitle {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonCardSubtitle = __decorate([ProxyCmp({\n    inputs: [\"color\", \"mode\"]\n  }), Component({\n    selector: \"ion-card-subtitle\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"color\", \"mode\"]\n  })], IonCardSubtitle);\n  return IonCardSubtitle;\n})();\nlet IonCardTitle = /*#__PURE__*/(() => {\n  let IonCardTitle = class IonCardTitle {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonCardTitle = __decorate([ProxyCmp({\n    inputs: [\"color\", \"mode\"]\n  }), Component({\n    selector: \"ion-card-title\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"color\", \"mode\"]\n  })], IonCardTitle);\n  return IonCardTitle;\n})();\nlet IonCheckbox = /*#__PURE__*/(() => {\n  let IonCheckbox = class IonCheckbox {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, [\"ionChange\", \"ionFocus\", \"ionBlur\"]);\n    }\n  };\n  IonCheckbox = __decorate([ProxyCmp({\n    inputs: [\"checked\", \"color\", \"disabled\", \"indeterminate\", \"mode\", \"name\", \"value\"]\n  }), Component({\n    selector: \"ion-checkbox\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"checked\", \"color\", \"disabled\", \"indeterminate\", \"mode\", \"name\", \"value\"]\n  })], IonCheckbox);\n  return IonCheckbox;\n})();\nlet IonChip = /*#__PURE__*/(() => {\n  let IonChip = class IonChip {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonChip = __decorate([ProxyCmp({\n    inputs: [\"color\", \"disabled\", \"mode\", \"outline\"]\n  }), Component({\n    selector: \"ion-chip\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"color\", \"disabled\", \"mode\", \"outline\"]\n  })], IonChip);\n  return IonChip;\n})();\nlet IonCol = /*#__PURE__*/(() => {\n  let IonCol = class IonCol {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonCol = __decorate([ProxyCmp({\n    inputs: [\"offset\", \"offsetLg\", \"offsetMd\", \"offsetSm\", \"offsetXl\", \"offsetXs\", \"pull\", \"pullLg\", \"pullMd\", \"pullSm\", \"pullXl\", \"pullXs\", \"push\", \"pushLg\", \"pushMd\", \"pushSm\", \"pushXl\", \"pushXs\", \"size\", \"sizeLg\", \"sizeMd\", \"sizeSm\", \"sizeXl\", \"sizeXs\"]\n  }), Component({\n    selector: \"ion-col\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"offset\", \"offsetLg\", \"offsetMd\", \"offsetSm\", \"offsetXl\", \"offsetXs\", \"pull\", \"pullLg\", \"pullMd\", \"pullSm\", \"pullXl\", \"pullXs\", \"push\", \"pushLg\", \"pushMd\", \"pushSm\", \"pushXl\", \"pushXs\", \"size\", \"sizeLg\", \"sizeMd\", \"sizeSm\", \"sizeXl\", \"sizeXs\"]\n  })], IonCol);\n  return IonCol;\n})();\nlet IonContent = /*#__PURE__*/(() => {\n  let IonContent = class IonContent {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, [\"ionScrollStart\", \"ionScroll\", \"ionScrollEnd\"]);\n    }\n  };\n  IonContent = __decorate([ProxyCmp({\n    inputs: [\"color\", \"forceOverscroll\", \"fullscreen\", \"scrollEvents\", \"scrollX\", \"scrollY\"],\n    \"methods\": [\"getScrollElement\", \"scrollToTop\", \"scrollToBottom\", \"scrollByPoint\", \"scrollToPoint\"]\n  }), Component({\n    selector: \"ion-content\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"color\", \"forceOverscroll\", \"fullscreen\", \"scrollEvents\", \"scrollX\", \"scrollY\"]\n  })], IonContent);\n  return IonContent;\n})();\nlet IonDatetime = /*#__PURE__*/(() => {\n  let IonDatetime = class IonDatetime {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, [\"ionCancel\", \"ionChange\", \"ionFocus\", \"ionBlur\"]);\n    }\n  };\n  IonDatetime = __decorate([ProxyCmp({\n    inputs: [\"cancelText\", \"dayNames\", \"dayShortNames\", \"dayValues\", \"disabled\", \"displayFormat\", \"displayTimezone\", \"doneText\", \"hourValues\", \"max\", \"min\", \"minuteValues\", \"mode\", \"monthNames\", \"monthShortNames\", \"monthValues\", \"name\", \"pickerFormat\", \"pickerOptions\", \"placeholder\", \"readonly\", \"value\", \"yearValues\"],\n    \"methods\": [\"open\"]\n  }), Component({\n    selector: \"ion-datetime\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"cancelText\", \"dayNames\", \"dayShortNames\", \"dayValues\", \"disabled\", \"displayFormat\", \"displayTimezone\", \"doneText\", \"hourValues\", \"max\", \"min\", \"minuteValues\", \"mode\", \"monthNames\", \"monthShortNames\", \"monthValues\", \"name\", \"pickerFormat\", \"pickerOptions\", \"placeholder\", \"readonly\", \"value\", \"yearValues\"]\n  })], IonDatetime);\n  return IonDatetime;\n})();\nlet IonFab = /*#__PURE__*/(() => {\n  let IonFab = class IonFab {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonFab = __decorate([ProxyCmp({\n    inputs: [\"activated\", \"edge\", \"horizontal\", \"vertical\"],\n    \"methods\": [\"close\"]\n  }), Component({\n    selector: \"ion-fab\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"activated\", \"edge\", \"horizontal\", \"vertical\"]\n  })], IonFab);\n  return IonFab;\n})();\nlet IonFabButton = /*#__PURE__*/(() => {\n  let IonFabButton = class IonFabButton {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, [\"ionFocus\", \"ionBlur\"]);\n    }\n  };\n  IonFabButton = __decorate([ProxyCmp({\n    inputs: [\"activated\", \"closeIcon\", \"color\", \"disabled\", \"download\", \"href\", \"mode\", \"rel\", \"routerAnimation\", \"routerDirection\", \"show\", \"size\", \"target\", \"translucent\", \"type\"]\n  }), Component({\n    selector: \"ion-fab-button\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"activated\", \"closeIcon\", \"color\", \"disabled\", \"download\", \"href\", \"mode\", \"rel\", \"routerAnimation\", \"routerDirection\", \"show\", \"size\", \"target\", \"translucent\", \"type\"]\n  })], IonFabButton);\n  return IonFabButton;\n})();\nlet IonFabList = /*#__PURE__*/(() => {\n  let IonFabList = class IonFabList {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonFabList = __decorate([ProxyCmp({\n    inputs: [\"activated\", \"side\"]\n  }), Component({\n    selector: \"ion-fab-list\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"activated\", \"side\"]\n  })], IonFabList);\n  return IonFabList;\n})();\nlet IonFooter = /*#__PURE__*/(() => {\n  let IonFooter = class IonFooter {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonFooter = __decorate([ProxyCmp({\n    inputs: [\"mode\", \"translucent\"]\n  }), Component({\n    selector: \"ion-footer\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"mode\", \"translucent\"]\n  })], IonFooter);\n  return IonFooter;\n})();\nlet IonGrid = /*#__PURE__*/(() => {\n  let IonGrid = class IonGrid {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonGrid = __decorate([ProxyCmp({\n    inputs: [\"fixed\"]\n  }), Component({\n    selector: \"ion-grid\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"fixed\"]\n  })], IonGrid);\n  return IonGrid;\n})();\nlet IonHeader = /*#__PURE__*/(() => {\n  let IonHeader = class IonHeader {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonHeader = __decorate([ProxyCmp({\n    inputs: [\"collapse\", \"mode\", \"translucent\"]\n  }), Component({\n    selector: \"ion-header\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"collapse\", \"mode\", \"translucent\"]\n  })], IonHeader);\n  return IonHeader;\n})();\nlet IonIcon = /*#__PURE__*/(() => {\n  let IonIcon = class IonIcon {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonIcon = __decorate([ProxyCmp({\n    inputs: [\"ariaLabel\", \"color\", \"flipRtl\", \"icon\", \"ios\", \"lazy\", \"md\", \"mode\", \"name\", \"size\", \"src\"]\n  }), Component({\n    selector: \"ion-icon\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"ariaLabel\", \"color\", \"flipRtl\", \"icon\", \"ios\", \"lazy\", \"md\", \"mode\", \"name\", \"size\", \"src\"]\n  })], IonIcon);\n  return IonIcon;\n})();\nlet IonImg = /*#__PURE__*/(() => {\n  let IonImg = class IonImg {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, [\"ionImgWillLoad\", \"ionImgDidLoad\", \"ionError\"]);\n    }\n  };\n  IonImg = __decorate([ProxyCmp({\n    inputs: [\"alt\", \"src\"]\n  }), Component({\n    selector: \"ion-img\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"alt\", \"src\"]\n  })], IonImg);\n  return IonImg;\n})();\nlet IonInfiniteScroll = /*#__PURE__*/(() => {\n  let IonInfiniteScroll = class IonInfiniteScroll {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, [\"ionInfinite\"]);\n    }\n  };\n  IonInfiniteScroll = __decorate([ProxyCmp({\n    inputs: [\"disabled\", \"position\", \"threshold\"],\n    \"methods\": [\"complete\"]\n  }), Component({\n    selector: \"ion-infinite-scroll\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"disabled\", \"position\", \"threshold\"]\n  })], IonInfiniteScroll);\n  return IonInfiniteScroll;\n})();\nlet IonInfiniteScrollContent = /*#__PURE__*/(() => {\n  let IonInfiniteScrollContent = class IonInfiniteScrollContent {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonInfiniteScrollContent = __decorate([ProxyCmp({\n    inputs: [\"loadingSpinner\", \"loadingText\"]\n  }), Component({\n    selector: \"ion-infinite-scroll-content\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"loadingSpinner\", \"loadingText\"]\n  })], IonInfiniteScrollContent);\n  return IonInfiniteScrollContent;\n})();\nlet IonInput = /*#__PURE__*/(() => {\n  let IonInput = class IonInput {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, [\"ionInput\", \"ionChange\", \"ionBlur\", \"ionFocus\"]);\n    }\n  };\n  IonInput = __decorate([ProxyCmp({\n    inputs: [\"accept\", \"autocapitalize\", \"autocomplete\", \"autocorrect\", \"autofocus\", \"clearInput\", \"clearOnEdit\", \"color\", \"debounce\", \"disabled\", \"enterkeyhint\", \"inputmode\", \"max\", \"maxlength\", \"min\", \"minlength\", \"mode\", \"multiple\", \"name\", \"pattern\", \"placeholder\", \"readonly\", \"required\", \"size\", \"spellcheck\", \"step\", \"type\", \"value\"],\n    \"methods\": [\"setFocus\", \"getInputElement\"]\n  }), Component({\n    selector: \"ion-input\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"accept\", \"autocapitalize\", \"autocomplete\", \"autocorrect\", \"autofocus\", \"clearInput\", \"clearOnEdit\", \"color\", \"debounce\", \"disabled\", \"enterkeyhint\", \"inputmode\", \"max\", \"maxlength\", \"min\", \"minlength\", \"mode\", \"multiple\", \"name\", \"pattern\", \"placeholder\", \"readonly\", \"required\", \"size\", \"spellcheck\", \"step\", \"type\", \"value\"]\n  })], IonInput);\n  return IonInput;\n})();\nlet IonItem = /*#__PURE__*/(() => {\n  let IonItem = class IonItem {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonItem = __decorate([ProxyCmp({\n    inputs: [\"button\", \"color\", \"detail\", \"detailIcon\", \"disabled\", \"download\", \"href\", \"lines\", \"mode\", \"rel\", \"routerAnimation\", \"routerDirection\", \"target\", \"type\"]\n  }), Component({\n    selector: \"ion-item\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"button\", \"color\", \"detail\", \"detailIcon\", \"disabled\", \"download\", \"href\", \"lines\", \"mode\", \"rel\", \"routerAnimation\", \"routerDirection\", \"target\", \"type\"]\n  })], IonItem);\n  return IonItem;\n})();\nlet IonItemDivider = /*#__PURE__*/(() => {\n  let IonItemDivider = class IonItemDivider {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonItemDivider = __decorate([ProxyCmp({\n    inputs: [\"color\", \"mode\", \"sticky\"]\n  }), Component({\n    selector: \"ion-item-divider\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"color\", \"mode\", \"sticky\"]\n  })], IonItemDivider);\n  return IonItemDivider;\n})();\nlet IonItemGroup = /*#__PURE__*/(() => {\n  let IonItemGroup = class IonItemGroup {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonItemGroup = __decorate([Component({\n    selector: \"ion-item-group\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\"\n  })], IonItemGroup);\n  return IonItemGroup;\n})();\nlet IonItemOption = /*#__PURE__*/(() => {\n  let IonItemOption = class IonItemOption {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonItemOption = __decorate([ProxyCmp({\n    inputs: [\"color\", \"disabled\", \"download\", \"expandable\", \"href\", \"mode\", \"rel\", \"target\", \"type\"]\n  }), Component({\n    selector: \"ion-item-option\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"color\", \"disabled\", \"download\", \"expandable\", \"href\", \"mode\", \"rel\", \"target\", \"type\"]\n  })], IonItemOption);\n  return IonItemOption;\n})();\nlet IonItemOptions = /*#__PURE__*/(() => {\n  let IonItemOptions = class IonItemOptions {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, [\"ionSwipe\"]);\n    }\n  };\n  IonItemOptions = __decorate([ProxyCmp({\n    inputs: [\"side\"]\n  }), Component({\n    selector: \"ion-item-options\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"side\"]\n  })], IonItemOptions);\n  return IonItemOptions;\n})();\nlet IonItemSliding = /*#__PURE__*/(() => {\n  let IonItemSliding = class IonItemSliding {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, [\"ionDrag\"]);\n    }\n  };\n  IonItemSliding = __decorate([ProxyCmp({\n    inputs: [\"disabled\"],\n    \"methods\": [\"getOpenAmount\", \"getSlidingRatio\", \"open\", \"close\", \"closeOpened\"]\n  }), Component({\n    selector: \"ion-item-sliding\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"disabled\"]\n  })], IonItemSliding);\n  return IonItemSliding;\n})();\nlet IonLabel = /*#__PURE__*/(() => {\n  let IonLabel = class IonLabel {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonLabel = __decorate([ProxyCmp({\n    inputs: [\"color\", \"mode\", \"position\"]\n  }), Component({\n    selector: \"ion-label\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"color\", \"mode\", \"position\"]\n  })], IonLabel);\n  return IonLabel;\n})();\nlet IonList = /*#__PURE__*/(() => {\n  let IonList = class IonList {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonList = __decorate([ProxyCmp({\n    inputs: [\"inset\", \"lines\", \"mode\"],\n    \"methods\": [\"closeSlidingItems\"]\n  }), Component({\n    selector: \"ion-list\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"inset\", \"lines\", \"mode\"]\n  })], IonList);\n  return IonList;\n})();\nlet IonListHeader = /*#__PURE__*/(() => {\n  let IonListHeader = class IonListHeader {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonListHeader = __decorate([ProxyCmp({\n    inputs: [\"color\", \"lines\", \"mode\"]\n  }), Component({\n    selector: \"ion-list-header\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"color\", \"lines\", \"mode\"]\n  })], IonListHeader);\n  return IonListHeader;\n})();\nlet IonMenu = /*#__PURE__*/(() => {\n  let IonMenu = class IonMenu {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, [\"ionWillOpen\", \"ionWillClose\", \"ionDidOpen\", \"ionDidClose\"]);\n    }\n  };\n  IonMenu = __decorate([ProxyCmp({\n    inputs: [\"contentId\", \"disabled\", \"maxEdgeStart\", \"menuId\", \"side\", \"swipeGesture\", \"type\"],\n    \"methods\": [\"isOpen\", \"isActive\", \"open\", \"close\", \"toggle\", \"setOpen\"]\n  }), Component({\n    selector: \"ion-menu\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"contentId\", \"disabled\", \"maxEdgeStart\", \"menuId\", \"side\", \"swipeGesture\", \"type\"]\n  })], IonMenu);\n  return IonMenu;\n})();\nlet IonMenuButton = /*#__PURE__*/(() => {\n  let IonMenuButton = class IonMenuButton {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonMenuButton = __decorate([ProxyCmp({\n    inputs: [\"autoHide\", \"color\", \"disabled\", \"menu\", \"mode\", \"type\"]\n  }), Component({\n    selector: \"ion-menu-button\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"autoHide\", \"color\", \"disabled\", \"menu\", \"mode\", \"type\"]\n  })], IonMenuButton);\n  return IonMenuButton;\n})();\nlet IonMenuToggle = /*#__PURE__*/(() => {\n  let IonMenuToggle = class IonMenuToggle {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonMenuToggle = __decorate([ProxyCmp({\n    inputs: [\"autoHide\", \"menu\"]\n  }), Component({\n    selector: \"ion-menu-toggle\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"autoHide\", \"menu\"]\n  })], IonMenuToggle);\n  return IonMenuToggle;\n})();\nlet IonNav = /*#__PURE__*/(() => {\n  let IonNav = class IonNav {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, [\"ionNavWillChange\", \"ionNavDidChange\"]);\n    }\n  };\n  IonNav = __decorate([ProxyCmp({\n    inputs: [\"animated\", \"animation\", \"root\", \"rootParams\", \"swipeGesture\"],\n    \"methods\": [\"push\", \"insert\", \"insertPages\", \"pop\", \"popTo\", \"popToRoot\", \"removeIndex\", \"setRoot\", \"setPages\", \"getActive\", \"getByIndex\", \"canGoBack\", \"getPrevious\"]\n  }), Component({\n    selector: \"ion-nav\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"animated\", \"animation\", \"root\", \"rootParams\", \"swipeGesture\"]\n  })], IonNav);\n  return IonNav;\n})();\nlet IonNavLink = /*#__PURE__*/(() => {\n  let IonNavLink = class IonNavLink {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonNavLink = __decorate([ProxyCmp({\n    inputs: [\"component\", \"componentProps\", \"routerAnimation\", \"routerDirection\"]\n  }), Component({\n    selector: \"ion-nav-link\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"component\", \"componentProps\", \"routerAnimation\", \"routerDirection\"]\n  })], IonNavLink);\n  return IonNavLink;\n})();\nlet IonNote = /*#__PURE__*/(() => {\n  let IonNote = class IonNote {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonNote = __decorate([ProxyCmp({\n    inputs: [\"color\", \"mode\"]\n  }), Component({\n    selector: \"ion-note\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"color\", \"mode\"]\n  })], IonNote);\n  return IonNote;\n})();\nlet IonProgressBar = /*#__PURE__*/(() => {\n  let IonProgressBar = class IonProgressBar {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonProgressBar = __decorate([ProxyCmp({\n    inputs: [\"buffer\", \"color\", \"mode\", \"reversed\", \"type\", \"value\"]\n  }), Component({\n    selector: \"ion-progress-bar\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"buffer\", \"color\", \"mode\", \"reversed\", \"type\", \"value\"]\n  })], IonProgressBar);\n  return IonProgressBar;\n})();\nlet IonRadio = /*#__PURE__*/(() => {\n  let IonRadio = class IonRadio {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, [\"ionFocus\", \"ionBlur\"]);\n    }\n  };\n  IonRadio = __decorate([ProxyCmp({\n    inputs: [\"color\", \"disabled\", \"mode\", \"name\", \"value\"]\n  }), Component({\n    selector: \"ion-radio\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"color\", \"disabled\", \"mode\", \"name\", \"value\"]\n  })], IonRadio);\n  return IonRadio;\n})();\nlet IonRadioGroup = /*#__PURE__*/(() => {\n  let IonRadioGroup = class IonRadioGroup {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, [\"ionChange\"]);\n    }\n  };\n  IonRadioGroup = __decorate([ProxyCmp({\n    inputs: [\"allowEmptySelection\", \"name\", \"value\"]\n  }), Component({\n    selector: \"ion-radio-group\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"allowEmptySelection\", \"name\", \"value\"]\n  })], IonRadioGroup);\n  return IonRadioGroup;\n})();\nlet IonRange = /*#__PURE__*/(() => {\n  let IonRange = class IonRange {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, [\"ionChange\", \"ionFocus\", \"ionBlur\"]);\n    }\n  };\n  IonRange = __decorate([ProxyCmp({\n    inputs: [\"color\", \"debounce\", \"disabled\", \"dualKnobs\", \"max\", \"min\", \"mode\", \"name\", \"pin\", \"snaps\", \"step\", \"ticks\", \"value\"]\n  }), Component({\n    selector: \"ion-range\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"color\", \"debounce\", \"disabled\", \"dualKnobs\", \"max\", \"min\", \"mode\", \"name\", \"pin\", \"snaps\", \"step\", \"ticks\", \"value\"]\n  })], IonRange);\n  return IonRange;\n})();\nlet IonRefresher = /*#__PURE__*/(() => {\n  let IonRefresher = class IonRefresher {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, [\"ionRefresh\", \"ionPull\", \"ionStart\"]);\n    }\n  };\n  IonRefresher = __decorate([ProxyCmp({\n    inputs: [\"closeDuration\", \"disabled\", \"pullFactor\", \"pullMax\", \"pullMin\", \"snapbackDuration\"],\n    \"methods\": [\"complete\", \"cancel\", \"getProgress\"]\n  }), Component({\n    selector: \"ion-refresher\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"closeDuration\", \"disabled\", \"pullFactor\", \"pullMax\", \"pullMin\", \"snapbackDuration\"]\n  })], IonRefresher);\n  return IonRefresher;\n})();\nlet IonRefresherContent = /*#__PURE__*/(() => {\n  let IonRefresherContent = class IonRefresherContent {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonRefresherContent = __decorate([ProxyCmp({\n    inputs: [\"pullingIcon\", \"pullingText\", \"refreshingSpinner\", \"refreshingText\"]\n  }), Component({\n    selector: \"ion-refresher-content\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"pullingIcon\", \"pullingText\", \"refreshingSpinner\", \"refreshingText\"]\n  })], IonRefresherContent);\n  return IonRefresherContent;\n})();\nlet IonReorder = /*#__PURE__*/(() => {\n  let IonReorder = class IonReorder {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonReorder = __decorate([Component({\n    selector: \"ion-reorder\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\"\n  })], IonReorder);\n  return IonReorder;\n})();\nlet IonReorderGroup = /*#__PURE__*/(() => {\n  let IonReorderGroup = class IonReorderGroup {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, [\"ionItemReorder\"]);\n    }\n  };\n  IonReorderGroup = __decorate([ProxyCmp({\n    inputs: [\"disabled\"],\n    \"methods\": [\"complete\"]\n  }), Component({\n    selector: \"ion-reorder-group\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"disabled\"]\n  })], IonReorderGroup);\n  return IonReorderGroup;\n})();\nlet IonRippleEffect = /*#__PURE__*/(() => {\n  let IonRippleEffect = class IonRippleEffect {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonRippleEffect = __decorate([ProxyCmp({\n    inputs: [\"type\"],\n    \"methods\": [\"addRipple\"]\n  }), Component({\n    selector: \"ion-ripple-effect\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"type\"]\n  })], IonRippleEffect);\n  return IonRippleEffect;\n})();\nlet IonRow = /*#__PURE__*/(() => {\n  let IonRow = class IonRow {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonRow = __decorate([Component({\n    selector: \"ion-row\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\"\n  })], IonRow);\n  return IonRow;\n})();\nlet IonSearchbar = /*#__PURE__*/(() => {\n  let IonSearchbar = class IonSearchbar {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, [\"ionInput\", \"ionChange\", \"ionCancel\", \"ionClear\", \"ionBlur\", \"ionFocus\"]);\n    }\n  };\n  IonSearchbar = __decorate([ProxyCmp({\n    inputs: [\"animated\", \"autocomplete\", \"autocorrect\", \"cancelButtonIcon\", \"cancelButtonText\", \"clearIcon\", \"color\", \"debounce\", \"disabled\", \"enterkeyhint\", \"inputmode\", \"mode\", \"placeholder\", \"searchIcon\", \"showCancelButton\", \"spellcheck\", \"type\", \"value\"],\n    \"methods\": [\"setFocus\", \"getInputElement\"]\n  }), Component({\n    selector: \"ion-searchbar\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"animated\", \"autocomplete\", \"autocorrect\", \"cancelButtonIcon\", \"cancelButtonText\", \"clearIcon\", \"color\", \"debounce\", \"disabled\", \"enterkeyhint\", \"inputmode\", \"mode\", \"placeholder\", \"searchIcon\", \"showCancelButton\", \"spellcheck\", \"type\", \"value\"]\n  })], IonSearchbar);\n  return IonSearchbar;\n})();\nlet IonSegment = /*#__PURE__*/(() => {\n  let IonSegment = class IonSegment {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, [\"ionChange\"]);\n    }\n  };\n  IonSegment = __decorate([ProxyCmp({\n    inputs: [\"color\", \"disabled\", \"mode\", \"scrollable\", \"swipeGesture\", \"value\"]\n  }), Component({\n    selector: \"ion-segment\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"color\", \"disabled\", \"mode\", \"scrollable\", \"swipeGesture\", \"value\"]\n  })], IonSegment);\n  return IonSegment;\n})();\nlet IonSegmentButton = /*#__PURE__*/(() => {\n  let IonSegmentButton = class IonSegmentButton {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonSegmentButton = __decorate([ProxyCmp({\n    inputs: [\"disabled\", \"layout\", \"mode\", \"type\", \"value\"]\n  }), Component({\n    selector: \"ion-segment-button\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"disabled\", \"layout\", \"mode\", \"type\", \"value\"]\n  })], IonSegmentButton);\n  return IonSegmentButton;\n})();\nlet IonSelect = /*#__PURE__*/(() => {\n  let IonSelect = class IonSelect {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, [\"ionChange\", \"ionCancel\", \"ionFocus\", \"ionBlur\"]);\n    }\n  };\n  IonSelect = __decorate([ProxyCmp({\n    inputs: [\"cancelText\", \"compareWith\", \"disabled\", \"interface\", \"interfaceOptions\", \"mode\", \"multiple\", \"name\", \"okText\", \"placeholder\", \"selectedText\", \"value\"],\n    \"methods\": [\"open\"]\n  }), Component({\n    selector: \"ion-select\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"cancelText\", \"compareWith\", \"disabled\", \"interface\", \"interfaceOptions\", \"mode\", \"multiple\", \"name\", \"okText\", \"placeholder\", \"selectedText\", \"value\"]\n  })], IonSelect);\n  return IonSelect;\n})();\nlet IonSelectOption = /*#__PURE__*/(() => {\n  let IonSelectOption = class IonSelectOption {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonSelectOption = __decorate([ProxyCmp({\n    inputs: [\"disabled\", \"value\"]\n  }), Component({\n    selector: \"ion-select-option\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"disabled\", \"value\"]\n  })], IonSelectOption);\n  return IonSelectOption;\n})();\nlet IonSkeletonText = /*#__PURE__*/(() => {\n  let IonSkeletonText = class IonSkeletonText {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonSkeletonText = __decorate([ProxyCmp({\n    inputs: [\"animated\"]\n  }), Component({\n    selector: \"ion-skeleton-text\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"animated\"]\n  })], IonSkeletonText);\n  return IonSkeletonText;\n})();\nlet IonSlide = /*#__PURE__*/(() => {\n  let IonSlide = class IonSlide {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonSlide = __decorate([Component({\n    selector: \"ion-slide\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\"\n  })], IonSlide);\n  return IonSlide;\n})();\nlet IonSlides = /*#__PURE__*/(() => {\n  let IonSlides = class IonSlides {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, [\"ionSlidesDidLoad\", \"ionSlideTap\", \"ionSlideDoubleTap\", \"ionSlideWillChange\", \"ionSlideDidChange\", \"ionSlideNextStart\", \"ionSlidePrevStart\", \"ionSlideNextEnd\", \"ionSlidePrevEnd\", \"ionSlideTransitionStart\", \"ionSlideTransitionEnd\", \"ionSlideDrag\", \"ionSlideReachStart\", \"ionSlideReachEnd\", \"ionSlideTouchStart\", \"ionSlideTouchEnd\"]);\n    }\n  };\n  IonSlides = __decorate([ProxyCmp({\n    inputs: [\"mode\", \"options\", \"pager\", \"scrollbar\"],\n    \"methods\": [\"update\", \"updateAutoHeight\", \"slideTo\", \"slideNext\", \"slidePrev\", \"getActiveIndex\", \"getPreviousIndex\", \"length\", \"isEnd\", \"isBeginning\", \"startAutoplay\", \"stopAutoplay\", \"lockSwipeToNext\", \"lockSwipeToPrev\", \"lockSwipes\", \"getSwiper\"]\n  }), Component({\n    selector: \"ion-slides\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"mode\", \"options\", \"pager\", \"scrollbar\"]\n  })], IonSlides);\n  return IonSlides;\n})();\nlet IonSpinner = /*#__PURE__*/(() => {\n  let IonSpinner = class IonSpinner {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonSpinner = __decorate([ProxyCmp({\n    inputs: [\"color\", \"duration\", \"name\", \"paused\"]\n  }), Component({\n    selector: \"ion-spinner\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"color\", \"duration\", \"name\", \"paused\"]\n  })], IonSpinner);\n  return IonSpinner;\n})();\nlet IonSplitPane = /*#__PURE__*/(() => {\n  let IonSplitPane = class IonSplitPane {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, [\"ionSplitPaneVisible\"]);\n    }\n  };\n  IonSplitPane = __decorate([ProxyCmp({\n    inputs: [\"contentId\", \"disabled\", \"when\"]\n  }), Component({\n    selector: \"ion-split-pane\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"contentId\", \"disabled\", \"when\"]\n  })], IonSplitPane);\n  return IonSplitPane;\n})();\nlet IonTabBar = /*#__PURE__*/(() => {\n  let IonTabBar = class IonTabBar {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonTabBar = __decorate([ProxyCmp({\n    inputs: [\"color\", \"mode\", \"selectedTab\", \"translucent\"]\n  }), Component({\n    selector: \"ion-tab-bar\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"color\", \"mode\", \"selectedTab\", \"translucent\"]\n  })], IonTabBar);\n  return IonTabBar;\n})();\nlet IonTabButton = /*#__PURE__*/(() => {\n  let IonTabButton = class IonTabButton {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonTabButton = __decorate([ProxyCmp({\n    inputs: [\"disabled\", \"download\", \"href\", \"layout\", \"mode\", \"rel\", \"selected\", \"tab\", \"target\"]\n  }), Component({\n    selector: \"ion-tab-button\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"disabled\", \"download\", \"href\", \"layout\", \"mode\", \"rel\", \"selected\", \"tab\", \"target\"]\n  })], IonTabButton);\n  return IonTabButton;\n})();\nlet IonText = /*#__PURE__*/(() => {\n  let IonText = class IonText {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonText = __decorate([ProxyCmp({\n    inputs: [\"color\", \"mode\"]\n  }), Component({\n    selector: \"ion-text\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"color\", \"mode\"]\n  })], IonText);\n  return IonText;\n})();\nlet IonTextarea = /*#__PURE__*/(() => {\n  let IonTextarea = class IonTextarea {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, [\"ionChange\", \"ionInput\", \"ionBlur\", \"ionFocus\"]);\n    }\n  };\n  IonTextarea = __decorate([ProxyCmp({\n    inputs: [\"autoGrow\", \"autocapitalize\", \"autofocus\", \"clearOnEdit\", \"color\", \"cols\", \"debounce\", \"disabled\", \"enterkeyhint\", \"inputmode\", \"maxlength\", \"minlength\", \"mode\", \"name\", \"placeholder\", \"readonly\", \"required\", \"rows\", \"spellcheck\", \"value\", \"wrap\"],\n    \"methods\": [\"setFocus\", \"getInputElement\"]\n  }), Component({\n    selector: \"ion-textarea\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"autoGrow\", \"autocapitalize\", \"autofocus\", \"clearOnEdit\", \"color\", \"cols\", \"debounce\", \"disabled\", \"enterkeyhint\", \"inputmode\", \"maxlength\", \"minlength\", \"mode\", \"name\", \"placeholder\", \"readonly\", \"required\", \"rows\", \"spellcheck\", \"value\", \"wrap\"]\n  })], IonTextarea);\n  return IonTextarea;\n})();\nlet IonThumbnail = /*#__PURE__*/(() => {\n  let IonThumbnail = class IonThumbnail {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonThumbnail = __decorate([Component({\n    selector: \"ion-thumbnail\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\"\n  })], IonThumbnail);\n  return IonThumbnail;\n})();\nlet IonTitle = /*#__PURE__*/(() => {\n  let IonTitle = class IonTitle {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonTitle = __decorate([ProxyCmp({\n    inputs: [\"color\", \"size\"]\n  }), Component({\n    selector: \"ion-title\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"color\", \"size\"]\n  })], IonTitle);\n  return IonTitle;\n})();\nlet IonToggle = /*#__PURE__*/(() => {\n  let IonToggle = class IonToggle {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n      proxyOutputs(this, this.el, [\"ionChange\", \"ionFocus\", \"ionBlur\"]);\n    }\n  };\n  IonToggle = __decorate([ProxyCmp({\n    inputs: [\"checked\", \"color\", \"disabled\", \"mode\", \"name\", \"value\"]\n  }), Component({\n    selector: \"ion-toggle\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"checked\", \"color\", \"disabled\", \"mode\", \"name\", \"value\"]\n  })], IonToggle);\n  return IonToggle;\n})();\nlet IonToolbar = /*#__PURE__*/(() => {\n  let IonToolbar = class IonToolbar {\n    constructor(c, r, z) {\n      this.z = z;\n      c.detach();\n      this.el = r.nativeElement;\n    }\n  };\n  IonToolbar = __decorate([ProxyCmp({\n    inputs: [\"color\", \"mode\"]\n  }), Component({\n    selector: \"ion-toolbar\",\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    template: \"<ng-content></ng-content>\",\n    inputs: [\"color\", \"mode\"]\n  })], IonToolbar);\n  return IonToolbar;\n})();\nlet Config = class Config {\n  get(key, fallback) {\n    const c = getConfig();\n    if (c) {\n      return c.get(key, fallback);\n    }\n    return null;\n  }\n  getBoolean(key, fallback) {\n    const c = getConfig();\n    if (c) {\n      return c.getBoolean(key, fallback);\n    }\n    return false;\n  }\n  getNumber(key, fallback) {\n    const c = getConfig();\n    if (c) {\n      return c.getNumber(key, fallback);\n    }\n    return 0;\n  }\n  set(key, value) {\n    console.warn(`[DEPRECATION][Config]: The Config.set() method is deprecated and will be removed in Ionic Framework 6.0. Please see https://ionicframework.com/docs/angular/config for alternatives.`);\n    const c = getConfig();\n    if (c) {\n      c.set(key, value);\n    }\n  }\n};\nConfig.ngInjectableDef = ɵɵdefineInjectable({\n  factory: function Config_Factory() {\n    return new Config();\n  },\n  token: Config,\n  providedIn: \"root\"\n});\nConfig = __decorate([Injectable({\n  providedIn: 'root'\n})], Config);\nconst ConfigToken = new InjectionToken('USERCONFIG');\nconst getConfig = () => {\n  if (typeof window !== 'undefined') {\n    const Ionic = window.Ionic;\n    if (Ionic && Ionic.config) {\n      return Ionic.config;\n    }\n  }\n  return null;\n};\nconst ɵ0$3 = getConfig;\n\n/**\n * @description\n * NavParams are an object that exists on a page and can contain data for that particular view.\n * Similar to how data was pass to a view in V1 with `$stateParams`, NavParams offer a much more flexible\n * option with a simple `get` method.\n *\n * @usage\n * ```ts\n * import { NavParams } from '@ionic/angular';\n *\n * export class MyClass{\n *\n *  constructor(navParams: NavParams){\n *    // userParams is an object we have in our nav-parameters\n *    navParams.get('userParams');\n *  }\n *\n * }\n * ```\n */\nclass NavParams {\n  constructor(data = {}) {\n    this.data = data;\n  }\n  /**\n   * Get the value of a nav-parameter for the current view\n   *\n   * ```ts\n   * import { NavParams } from 'ionic-angular';\n   *\n   * export class MyClass{\n   *  constructor(public navParams: NavParams){\n   *    // userParams is an object we have in our nav-parameters\n   *    this.navParams.get('userParams');\n   *  }\n   * }\n   * ```\n   *\n   * @param param Which param you want to look up\n   */\n  get(param) {\n    return this.data[param];\n  }\n}\nlet AngularDelegate = /*#__PURE__*/(() => {\n  let AngularDelegate = class AngularDelegate {\n    constructor(zone, appRef) {\n      this.zone = zone;\n      this.appRef = appRef;\n    }\n    create(resolver, injector, location) {\n      return new AngularFrameworkDelegate(resolver, injector, location, this.appRef, this.zone);\n    }\n  };\n  AngularDelegate = __decorate([Injectable()], AngularDelegate);\n  return AngularDelegate;\n})();\nclass AngularFrameworkDelegate {\n  constructor(resolver, injector, location, appRef, zone) {\n    this.resolver = resolver;\n    this.injector = injector;\n    this.location = location;\n    this.appRef = appRef;\n    this.zone = zone;\n    this.elRefMap = new WeakMap();\n    this.elEventsMap = new WeakMap();\n  }\n  attachViewToDom(container, component, params, cssClasses) {\n    return this.zone.run(() => {\n      return new Promise(resolve => {\n        const el = attachView(this.zone, this.resolver, this.injector, this.location, this.appRef, this.elRefMap, this.elEventsMap, container, component, params, cssClasses);\n        resolve(el);\n      });\n    });\n  }\n  removeViewFromDom(_container, component) {\n    return this.zone.run(() => {\n      return new Promise(resolve => {\n        const componentRef = this.elRefMap.get(component);\n        if (componentRef) {\n          componentRef.destroy();\n          this.elRefMap.delete(component);\n          const unbindEvents = this.elEventsMap.get(component);\n          if (unbindEvents) {\n            unbindEvents();\n            this.elEventsMap.delete(component);\n          }\n        }\n        resolve();\n      });\n    });\n  }\n}\nconst attachView = (zone, resolver, injector, location, appRef, elRefMap, elEventsMap, container, component, params, cssClasses) => {\n  const factory = resolver.resolveComponentFactory(component);\n  const childInjector = Injector.create({\n    providers: getProviders(params),\n    parent: injector\n  });\n  const componentRef = location ? location.createComponent(factory, location.length, childInjector) : factory.create(childInjector);\n  const instance = componentRef.instance;\n  const hostElement = componentRef.location.nativeElement;\n  if (params) {\n    Object.assign(instance, params);\n  }\n  if (cssClasses) {\n    for (const clazz of cssClasses) {\n      hostElement.classList.add(clazz);\n    }\n  }\n  const unbindEvents = bindLifecycleEvents(zone, instance, hostElement);\n  container.appendChild(hostElement);\n  if (!location) {\n    appRef.attachView(componentRef.hostView);\n  }\n  componentRef.changeDetectorRef.reattach();\n  elRefMap.set(hostElement, componentRef);\n  elEventsMap.set(hostElement, unbindEvents);\n  return hostElement;\n};\nconst LIFECYCLES = [LIFECYCLE_WILL_ENTER, LIFECYCLE_DID_ENTER, LIFECYCLE_WILL_LEAVE, LIFECYCLE_DID_LEAVE, LIFECYCLE_WILL_UNLOAD];\nconst bindLifecycleEvents = (zone, instance, element) => {\n  return zone.run(() => {\n    const unregisters = LIFECYCLES.filter(eventName => typeof instance[eventName] === 'function').map(eventName => {\n      const handler = ev => instance[eventName](ev.detail);\n      element.addEventListener(eventName, handler);\n      return () => element.removeEventListener(eventName, handler);\n    });\n    return () => unregisters.forEach(fn => fn());\n  });\n};\nconst NavParamsToken = new InjectionToken('NavParamsToken');\nconst getProviders = params => {\n  return [{\n    provide: NavParamsToken,\n    useValue: params\n  }, {\n    provide: NavParams,\n    useFactory: provideNavParamsInjectable,\n    deps: [NavParamsToken]\n  }];\n};\nconst ɵ0$4 = getProviders;\nconst provideNavParamsInjectable = params => {\n  return new NavParams(params);\n};\nconst ɵ1$2 = provideNavParamsInjectable;\nconst insertView = (views, view, direction) => {\n  if (direction === 'root') {\n    return setRoot(views, view);\n  } else if (direction === 'forward') {\n    return setForward(views, view);\n  } else {\n    return setBack(views, view);\n  }\n};\nconst setRoot = (views, view) => {\n  views = views.filter(v => v.stackId !== view.stackId);\n  views.push(view);\n  return views;\n};\nconst ɵ0$5 = setRoot;\nconst setForward = (views, view) => {\n  const index = views.indexOf(view);\n  if (index >= 0) {\n    views = views.filter(v => v.stackId !== view.stackId || v.id <= view.id);\n  } else {\n    views.push(view);\n  }\n  return views;\n};\nconst ɵ1$3 = setForward;\nconst setBack = (views, view) => {\n  const index = views.indexOf(view);\n  if (index >= 0) {\n    return views.filter(v => v.stackId !== view.stackId || v.id <= view.id);\n  } else {\n    return setRoot(views, view);\n  }\n};\nconst ɵ2$1 = setBack;\nconst getUrl = (router, activatedRoute) => {\n  const urlTree = router.createUrlTree(['.'], {\n    relativeTo: activatedRoute\n  });\n  return router.serializeUrl(urlTree);\n};\nconst isTabSwitch = (enteringView, leavingView) => {\n  if (!leavingView) {\n    return true;\n  }\n  return enteringView.stackId !== leavingView.stackId;\n};\nconst computeStackId = (prefixUrl, url) => {\n  if (!prefixUrl) {\n    return undefined;\n  }\n  const segments = toSegments(url);\n  for (let i = 0; i < segments.length; i++) {\n    if (i >= prefixUrl.length) {\n      return segments[i];\n    }\n    if (segments[i] !== prefixUrl[i]) {\n      return undefined;\n    }\n  }\n  return undefined;\n};\nconst toSegments = path => {\n  return path.split('/').map(s => s.trim()).filter(s => s !== '');\n};\nconst destroyView = view => {\n  if (view) {\n    // TODO lifecycle event\n    view.ref.destroy();\n    view.unlistenEvents();\n  }\n};\nclass StackController {\n  constructor(tabsPrefix, containerEl, router, navCtrl, zone, location) {\n    this.containerEl = containerEl;\n    this.router = router;\n    this.navCtrl = navCtrl;\n    this.zone = zone;\n    this.location = location;\n    this.views = [];\n    this.skipTransition = false;\n    this.nextId = 0;\n    this.tabsPrefix = tabsPrefix !== undefined ? toSegments(tabsPrefix) : undefined;\n  }\n  createView(ref, activatedRoute) {\n    const url = getUrl(this.router, activatedRoute);\n    const element = ref && ref.location && ref.location.nativeElement;\n    const unlistenEvents = bindLifecycleEvents(this.zone, ref.instance, element);\n    return {\n      id: this.nextId++,\n      stackId: computeStackId(this.tabsPrefix, url),\n      unlistenEvents,\n      element,\n      ref,\n      url\n    };\n  }\n  getExistingView(activatedRoute) {\n    const activatedUrlKey = getUrl(this.router, activatedRoute);\n    const view = this.views.find(vw => vw.url === activatedUrlKey);\n    if (view) {\n      view.ref.changeDetectorRef.reattach();\n    }\n    return view;\n  }\n  setActive(enteringView) {\n    const consumeResult = this.navCtrl.consumeTransition();\n    let {\n      direction,\n      animation,\n      animationBuilder\n    } = consumeResult;\n    const leavingView = this.activeView;\n    const tabSwitch = isTabSwitch(enteringView, leavingView);\n    if (tabSwitch) {\n      direction = 'back';\n      animation = undefined;\n    }\n    const viewsSnapshot = this.views.slice();\n    let currentNavigation;\n    const router = this.router;\n    // Angular >= 7.2.0\n    if (router.getCurrentNavigation) {\n      currentNavigation = router.getCurrentNavigation();\n      // Angular < 7.2.0\n    } else if (router.navigations && router.navigations.value) {\n      currentNavigation = router.navigations.value;\n    }\n    /**\n     * If the navigation action\n     * sets `replaceUrl: true`\n     * then we need to make sure\n     * we remove the last item\n     * from our views stack\n     */\n    if (currentNavigation && currentNavigation.extras && currentNavigation.extras.replaceUrl) {\n      if (this.views.length > 0) {\n        this.views.splice(-1, 1);\n      }\n    }\n    const reused = this.views.includes(enteringView);\n    const views = this.insertView(enteringView, direction);\n    // Trigger change detection before transition starts\n    // This will call ngOnInit() the first time too, just after the view\n    // was attached to the dom, but BEFORE the transition starts\n    if (!reused) {\n      enteringView.ref.changeDetectorRef.detectChanges();\n    }\n    /**\n     * If we are going back from a page that\n     * was presented using a custom animation\n     * we should default to using that\n     * unless the developer explicitly\n     * provided another animation.\n     */\n    const customAnimation = enteringView.animationBuilder;\n    if (animationBuilder === undefined && direction === 'back' && !tabSwitch && customAnimation !== undefined) {\n      animationBuilder = customAnimation;\n    }\n    /**\n     * Save any custom animation so that navigating\n     * back will use this custom animation by default.\n     */\n    if (leavingView) {\n      leavingView.animationBuilder = animationBuilder;\n    }\n    // Wait until previous transitions finish\n    return this.zone.runOutsideAngular(() => {\n      return this.wait(() => {\n        // disconnect leaving page from change detection to\n        // reduce jank during the page transition\n        if (leavingView) {\n          leavingView.ref.changeDetectorRef.detach();\n        }\n        // In case the enteringView is the same as the leavingPage we need to reattach()\n        enteringView.ref.changeDetectorRef.reattach();\n        return this.transition(enteringView, leavingView, animation, this.canGoBack(1), false, animationBuilder).then(() => cleanupAsync(enteringView, views, viewsSnapshot, this.location)).then(() => ({\n          enteringView,\n          direction,\n          animation,\n          tabSwitch\n        }));\n      });\n    });\n  }\n  canGoBack(deep, stackId = this.getActiveStackId()) {\n    return this.getStack(stackId).length > deep;\n  }\n  pop(deep, stackId = this.getActiveStackId()) {\n    return this.zone.run(() => {\n      const views = this.getStack(stackId);\n      if (views.length <= deep) {\n        return Promise.resolve(false);\n      }\n      const view = views[views.length - deep - 1];\n      let url = view.url;\n      const viewSavedData = view.savedData;\n      if (viewSavedData) {\n        const primaryOutlet = viewSavedData.get('primary');\n        if (primaryOutlet && primaryOutlet.route && primaryOutlet.route._routerState && primaryOutlet.route._routerState.snapshot && primaryOutlet.route._routerState.snapshot.url) {\n          url = primaryOutlet.route._routerState.snapshot.url;\n        }\n      }\n      const {\n        animationBuilder\n      } = this.navCtrl.consumeTransition();\n      return this.navCtrl.navigateBack(url, Object.assign({}, view.savedExtras, {\n        animation: animationBuilder\n      })).then(() => true);\n    });\n  }\n  startBackTransition() {\n    const leavingView = this.activeView;\n    if (leavingView) {\n      const views = this.getStack(leavingView.stackId);\n      const enteringView = views[views.length - 2];\n      const customAnimation = enteringView.animationBuilder;\n      return this.wait(() => {\n        return this.transition(enteringView,\n        // entering view\n        leavingView,\n        // leaving view\n        'back', this.canGoBack(2), true, customAnimation);\n      });\n    }\n    return Promise.resolve();\n  }\n  endBackTransition(shouldComplete) {\n    if (shouldComplete) {\n      this.skipTransition = true;\n      this.pop(1);\n    } else if (this.activeView) {\n      cleanup(this.activeView, this.views, this.views, this.location);\n    }\n  }\n  getLastUrl(stackId) {\n    const views = this.getStack(stackId);\n    return views.length > 0 ? views[views.length - 1] : undefined;\n  }\n  /**\n   * @internal\n   */\n  getRootUrl(stackId) {\n    const views = this.getStack(stackId);\n    return views.length > 0 ? views[0] : undefined;\n  }\n  getActiveStackId() {\n    return this.activeView ? this.activeView.stackId : undefined;\n  }\n  destroy() {\n    this.containerEl = undefined;\n    this.views.forEach(destroyView);\n    this.activeView = undefined;\n    this.views = [];\n  }\n  getStack(stackId) {\n    return this.views.filter(v => v.stackId === stackId);\n  }\n  insertView(enteringView, direction) {\n    this.activeView = enteringView;\n    this.views = insertView(this.views, enteringView, direction);\n    return this.views.slice();\n  }\n  transition(enteringView, leavingView, direction, showGoBack, progressAnimation, animationBuilder) {\n    if (this.skipTransition) {\n      this.skipTransition = false;\n      return Promise.resolve(false);\n    }\n    if (leavingView === enteringView) {\n      return Promise.resolve(false);\n    }\n    const enteringEl = enteringView ? enteringView.element : undefined;\n    const leavingEl = leavingView ? leavingView.element : undefined;\n    const containerEl = this.containerEl;\n    if (enteringEl && enteringEl !== leavingEl) {\n      enteringEl.classList.add('ion-page');\n      enteringEl.classList.add('ion-page-invisible');\n      if (enteringEl.parentElement !== containerEl) {\n        containerEl.appendChild(enteringEl);\n      }\n      if (containerEl.commit) {\n        return containerEl.commit(enteringEl, leavingEl, {\n          deepWait: true,\n          duration: direction === undefined ? 0 : undefined,\n          direction,\n          showGoBack,\n          progressAnimation,\n          animationBuilder\n        });\n      }\n    }\n    return Promise.resolve(false);\n  }\n  wait(task) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.runningTask !== undefined) {\n        yield this.runningTask;\n        this.runningTask = undefined;\n      }\n      const promise = this.runningTask = task();\n      return promise;\n    });\n  }\n}\nconst cleanupAsync = (activeRoute, views, viewsSnapshot, location) => {\n  if (typeof requestAnimationFrame === 'function') {\n    return new Promise(resolve => {\n      requestAnimationFrame(() => {\n        cleanup(activeRoute, views, viewsSnapshot, location);\n        resolve();\n      });\n    });\n  }\n  return Promise.resolve();\n};\nconst ɵ0$6 = cleanupAsync;\nconst cleanup = (activeRoute, views, viewsSnapshot, location) => {\n  viewsSnapshot.filter(view => !views.includes(view)).forEach(destroyView);\n  views.forEach(view => {\n    /**\n     * In the event that a user navigated multiple\n     * times in rapid succession, we want to make sure\n     * we don't pre-emptively detach a view while\n     * it is in mid-transition.\n     *\n     * In this instance we also do not care about query\n     * params or fragments as it will be the same view regardless\n     */\n    const locationWithoutParams = location.path().split('?')[0];\n    const locationWithoutFragment = locationWithoutParams.split('#')[0];\n    if (view !== activeRoute && view.url !== locationWithoutFragment) {\n      const element = view.element;\n      element.setAttribute('aria-hidden', 'true');\n      element.classList.add('ion-page-hidden');\n      view.ref.changeDetectorRef.detach();\n    }\n  });\n};\nconst ɵ1$4 = cleanup;\nlet IonRouterOutlet = /*#__PURE__*/(() => {\n  let IonRouterOutlet = class IonRouterOutlet {\n    constructor(parentContexts, location, resolver, name, tabs, config, navCtrl, commonLocation, elementRef, router, zone, activatedRoute, parentOutlet) {\n      this.parentContexts = parentContexts;\n      this.location = location;\n      this.resolver = resolver;\n      this.config = config;\n      this.navCtrl = navCtrl;\n      this.parentOutlet = parentOutlet;\n      this.activated = null;\n      this.activatedView = null;\n      this._activatedRoute = null;\n      // Maintain map of activated route proxies for each component instance\n      this.proxyMap = new WeakMap();\n      // Keep the latest activated route in a subject for the proxy routes to switch map to\n      this.currentActivatedRoute$ = new BehaviorSubject(null);\n      this.stackEvents = new EventEmitter();\n      this.activateEvents = new EventEmitter();\n      this.deactivateEvents = new EventEmitter();\n      this.nativeEl = elementRef.nativeElement;\n      this.name = name || PRIMARY_OUTLET;\n      this.tabsPrefix = tabs === 'true' ? getUrl(router, activatedRoute) : undefined;\n      this.stackCtrl = new StackController(this.tabsPrefix, this.nativeEl, router, navCtrl, zone, commonLocation);\n      parentContexts.onChildOutletCreated(this.name, this);\n    }\n    set animation(animation) {\n      this.nativeEl.animation = animation;\n    }\n    set animated(animated) {\n      this.nativeEl.animated = animated;\n    }\n    set swipeGesture(swipe) {\n      this._swipeGesture = swipe;\n      this.nativeEl.swipeHandler = swipe ? {\n        canStart: () => this.stackCtrl.canGoBack(1),\n        onStart: () => this.stackCtrl.startBackTransition(),\n        onEnd: shouldContinue => this.stackCtrl.endBackTransition(shouldContinue)\n      } : undefined;\n    }\n    ngOnDestroy() {\n      this.stackCtrl.destroy();\n    }\n    getContext() {\n      return this.parentContexts.getContext(this.name);\n    }\n    ngOnInit() {\n      if (!this.activated) {\n        // If the outlet was not instantiated at the time the route got activated we need to populate\n        // the outlet when it is initialized (ie inside a NgIf)\n        const context = this.getContext();\n        if (context && context.route) {\n          this.activateWith(context.route, context.resolver || null);\n        }\n      }\n      if (this.nativeEl.componentOnReady) {\n        this.nativeEl.componentOnReady().then(() => {\n          if (this._swipeGesture === undefined) {\n            this.swipeGesture = this.config.getBoolean('swipeBackEnabled', this.nativeEl.mode === 'ios');\n          }\n        });\n      }\n    }\n    get isActivated() {\n      return !!this.activated;\n    }\n    get component() {\n      if (!this.activated) {\n        throw new Error('Outlet is not activated');\n      }\n      return this.activated.instance;\n    }\n    get activatedRoute() {\n      if (!this.activated) {\n        throw new Error('Outlet is not activated');\n      }\n      return this._activatedRoute;\n    }\n    get activatedRouteData() {\n      if (this._activatedRoute) {\n        return this._activatedRoute.snapshot.data;\n      }\n      return {};\n    }\n    /**\n     * Called when the `RouteReuseStrategy` instructs to detach the subtree\n     */\n    detach() {\n      throw new Error('incompatible reuse strategy');\n    }\n    /**\n     * Called when the `RouteReuseStrategy` instructs to re-attach a previously detached subtree\n     */\n    attach(_ref, _activatedRoute) {\n      throw new Error('incompatible reuse strategy');\n    }\n    deactivate() {\n      if (this.activated) {\n        if (this.activatedView) {\n          this.activatedView.savedData = new Map(this.getContext().children['contexts']);\n          /**\n           * Ensure we are saving the NavigationExtras\n           * data otherwise it will be lost\n           */\n          this.activatedView.savedExtras = {};\n          const context = this.getContext();\n          if (context.route) {\n            const contextSnapshot = context.route.snapshot;\n            this.activatedView.savedExtras.queryParams = contextSnapshot.queryParams;\n            this.activatedView.savedExtras.fragment = contextSnapshot.fragment;\n          }\n        }\n        const c = this.component;\n        this.activatedView = null;\n        this.activated = null;\n        this._activatedRoute = null;\n        this.deactivateEvents.emit(c);\n      }\n    }\n    activateWith(activatedRoute, resolver) {\n      if (this.isActivated) {\n        throw new Error('Cannot activate an already activated outlet');\n      }\n      this._activatedRoute = activatedRoute;\n      let cmpRef;\n      let enteringView = this.stackCtrl.getExistingView(activatedRoute);\n      if (enteringView) {\n        cmpRef = this.activated = enteringView.ref;\n        const saved = enteringView.savedData;\n        if (saved) {\n          // self-restore\n          const context = this.getContext();\n          context.children['contexts'] = saved;\n        }\n        // Updated activated route proxy for this component\n        this.updateActivatedRouteProxy(cmpRef.instance, activatedRoute);\n      } else {\n        const snapshot = activatedRoute._futureSnapshot;\n        const component = snapshot.routeConfig.component;\n        resolver = resolver || this.resolver;\n        const factory = resolver.resolveComponentFactory(component);\n        const childContexts = this.parentContexts.getOrCreateContext(this.name).children;\n        // We create an activated route proxy object that will maintain future updates for this component\n        // over its lifecycle in the stack.\n        const component$ = new BehaviorSubject(null);\n        const activatedRouteProxy = this.createActivatedRouteProxy(component$, activatedRoute);\n        const injector = new OutletInjector(activatedRouteProxy, childContexts, this.location.injector);\n        cmpRef = this.activated = this.location.createComponent(factory, this.location.length, injector);\n        // Once the component is created we can push it to our local subject supplied to the proxy\n        component$.next(cmpRef.instance);\n        // Calling `markForCheck` to make sure we will run the change detection when the\n        // `RouterOutlet` is inside a `ChangeDetectionStrategy.OnPush` component.\n        enteringView = this.stackCtrl.createView(this.activated, activatedRoute);\n        // Store references to the proxy by component\n        this.proxyMap.set(cmpRef.instance, activatedRouteProxy);\n        this.currentActivatedRoute$.next({\n          component: cmpRef.instance,\n          activatedRoute\n        });\n      }\n      this.activatedView = enteringView;\n      this.stackCtrl.setActive(enteringView).then(data => {\n        this.navCtrl.setTopOutlet(this);\n        this.activateEvents.emit(cmpRef.instance);\n        this.stackEvents.emit(data);\n      });\n    }\n    /**\n     * Returns `true` if there are pages in the stack to go back.\n     */\n    canGoBack(deep = 1, stackId) {\n      return this.stackCtrl.canGoBack(deep, stackId);\n    }\n    /**\n     * Resolves to `true` if it the outlet was able to sucessfully pop the last N pages.\n     */\n    pop(deep = 1, stackId) {\n      return this.stackCtrl.pop(deep, stackId);\n    }\n    /**\n     * Returns the URL of the active page of each stack.\n     */\n    getLastUrl(stackId) {\n      const active = this.stackCtrl.getLastUrl(stackId);\n      return active ? active.url : undefined;\n    }\n    /**\n     * Returns the RouteView of the active page of each stack.\n     * @internal\n     */\n    getLastRouteView(stackId) {\n      return this.stackCtrl.getLastUrl(stackId);\n    }\n    /**\n     * Returns the root view in the tab stack.\n     * @internal\n     */\n    getRootView(stackId) {\n      return this.stackCtrl.getRootUrl(stackId);\n    }\n    /**\n     * Returns the active stack ID. In the context of ion-tabs, it means the active tab.\n     */\n    getActiveStackId() {\n      return this.stackCtrl.getActiveStackId();\n    }\n    /**\n     * Since the activated route can change over the life time of a component in an ion router outlet, we create\n     * a proxy so that we can update the values over time as a user navigates back to components already in the stack.\n     */\n    createActivatedRouteProxy(component$, activatedRoute) {\n      const proxy = new ActivatedRoute();\n      proxy._futureSnapshot = activatedRoute._futureSnapshot;\n      proxy._routerState = activatedRoute._routerState;\n      proxy.snapshot = activatedRoute.snapshot;\n      proxy.outlet = activatedRoute.outlet;\n      proxy.component = activatedRoute.component;\n      // Setup wrappers for the observables so consumers don't have to worry about switching to new observables as the state updates\n      proxy._paramMap = this.proxyObservable(component$, 'paramMap');\n      proxy._queryParamMap = this.proxyObservable(component$, 'queryParamMap');\n      proxy.url = this.proxyObservable(component$, 'url');\n      proxy.params = this.proxyObservable(component$, 'params');\n      proxy.queryParams = this.proxyObservable(component$, 'queryParams');\n      proxy.fragment = this.proxyObservable(component$, 'fragment');\n      proxy.data = this.proxyObservable(component$, 'data');\n      return proxy;\n    }\n    /**\n     * Create a wrapped observable that will switch to the latest activated route matched by the given component\n     */\n    proxyObservable(component$, path) {\n      return component$.pipe(\n      // First wait until the component instance is pushed\n      filter(component => !!component), switchMap(component => this.currentActivatedRoute$.pipe(filter(current => current !== null && current.component === component), switchMap(current => current && current.activatedRoute[path]), distinctUntilChanged())));\n    }\n    /**\n     * Updates the activated route proxy for the given component to the new incoming router state\n     */\n    updateActivatedRouteProxy(component, activatedRoute) {\n      const proxy = this.proxyMap.get(component);\n      if (!proxy) {\n        throw new Error(`Could not find activated route proxy for view`);\n      }\n      proxy._futureSnapshot = activatedRoute._futureSnapshot;\n      proxy._routerState = activatedRoute._routerState;\n      proxy.snapshot = activatedRoute.snapshot;\n      proxy.outlet = activatedRoute.outlet;\n      proxy.component = activatedRoute.component;\n      this.currentActivatedRoute$.next({\n        component,\n        activatedRoute\n      });\n    }\n  };\n  __decorate([Output()], IonRouterOutlet.prototype, \"stackEvents\", void 0);\n  __decorate([Output('activate')], IonRouterOutlet.prototype, \"activateEvents\", void 0);\n  __decorate([Output('deactivate')], IonRouterOutlet.prototype, \"deactivateEvents\", void 0);\n  IonRouterOutlet = __decorate([Directive({\n    selector: 'ion-router-outlet',\n    exportAs: 'outlet',\n    inputs: ['animated', 'animation', 'swipeGesture']\n  }), __param(3, Attribute('name')), __param(4, Optional()), __param(4, Attribute('tabs')), __param(12, SkipSelf()), __param(12, Optional())], IonRouterOutlet);\n  return IonRouterOutlet;\n})();\nclass OutletInjector {\n  constructor(route, childContexts, parent) {\n    this.route = route;\n    this.childContexts = childContexts;\n    this.parent = parent;\n  }\n  get(token, notFoundValue) {\n    if (token === ActivatedRoute) {\n      return this.route;\n    }\n    if (token === ChildrenOutletContexts) {\n      return this.childContexts;\n    }\n    // tslint:disable-next-line\n    return this.parent.get(token, notFoundValue);\n  }\n}\nlet IonTabs = /*#__PURE__*/(() => {\n  let IonTabs = class IonTabs {\n    constructor(navCtrl) {\n      this.navCtrl = navCtrl;\n      this.ionTabsWillChange = new EventEmitter();\n      this.ionTabsDidChange = new EventEmitter();\n    }\n    /**\n     * @internal\n     */\n    onPageSelected(detail) {\n      const stackId = detail.enteringView.stackId;\n      if (detail.tabSwitch && stackId !== undefined) {\n        if (this.tabBar) {\n          this.tabBar.selectedTab = stackId;\n        }\n        this.ionTabsWillChange.emit({\n          tab: stackId\n        });\n        this.ionTabsDidChange.emit({\n          tab: stackId\n        });\n      }\n    }\n    /**\n     * When a tab button is clicked, there are several scenarios:\n     * 1. If the selected tab is currently active (the tab button has been clicked\n     *    again), then it should go to the root view for that tab.\n     *\n     *   a. Get the saved root view from the router outlet. If the saved root view\n     *      matches the tabRootUrl, set the route view to this view including the\n     *      navigation extras.\n     *   b. If the saved root view from the router outlet does\n     *      not match, navigate to the tabRootUrl. No navigation extras are\n     *      included.\n     *\n     * 2. If the current tab tab is not currently selected, get the last route\n     *    view from the router outlet.\n     *\n     *   a. If the last route view exists, navigate to that view including any\n     *      navigation extras\n     *   b. If the last route view doesn't exist, then navigate\n     *      to the default tabRootUrl\n     */\n    select(tab) {\n      const alreadySelected = this.outlet.getActiveStackId() === tab;\n      const tabRootUrl = `${this.outlet.tabsPrefix}/${tab}`;\n      if (alreadySelected) {\n        const activeStackId = this.outlet.getActiveStackId();\n        const activeView = this.outlet.getLastRouteView(activeStackId);\n        // If on root tab, do not navigate to root tab again\n        if (activeView.url === tabRootUrl) {\n          return;\n        }\n        const rootView = this.outlet.getRootView(tab);\n        const navigationExtras = rootView && tabRootUrl === rootView.url && rootView.savedExtras;\n        return this.navCtrl.navigateRoot(tabRootUrl, Object.assign({}, navigationExtras, {\n          animated: true,\n          animationDirection: 'back'\n        }));\n      } else {\n        const lastRoute = this.outlet.getLastRouteView(tab);\n        /**\n         * If there is a lastRoute, goto that, otherwise goto the fallback url of the\n         * selected tab\n         */\n        const url = lastRoute && lastRoute.url || tabRootUrl;\n        const navigationExtras = lastRoute && lastRoute.savedExtras;\n        return this.navCtrl.navigateRoot(url, Object.assign({}, navigationExtras, {\n          animated: true,\n          animationDirection: 'back'\n        }));\n      }\n    }\n    getSelected() {\n      return this.outlet.getActiveStackId();\n    }\n  };\n  __decorate([ViewChild('outlet', {\n    read: IonRouterOutlet,\n    static: false\n  })], IonTabs.prototype, \"outlet\", void 0);\n  __decorate([ContentChild(IonTabBar, {\n    static: false\n  })], IonTabs.prototype, \"tabBar\", void 0);\n  __decorate([Output()], IonTabs.prototype, \"ionTabsWillChange\", void 0);\n  __decorate([Output()], IonTabs.prototype, \"ionTabsDidChange\", void 0);\n  __decorate([HostListener('ionTabButtonClick', ['$event.detail.tab'])], IonTabs.prototype, \"select\", null);\n  IonTabs = __decorate([Component({\n    selector: 'ion-tabs',\n    template: `\n    <ng-content select=\"[slot=top]\"></ng-content>\n    <div class=\"tabs-inner\">\n      <ion-router-outlet #outlet tabs=\"true\" (stackEvents)=\"onPageSelected($event)\"></ion-router-outlet>\n    </div>\n    <ng-content></ng-content>`,\n    styles: [`\n    :host {\n      display: flex;\n      position: absolute;\n      top: 0;\n      left: 0;\n      right: 0;\n      bottom: 0;\n\n      flex-direction: column;\n\n      width: 100%;\n      height: 100%;\n\n      contain: layout size style;\n      z-index: $z-index-page-container;\n    }\n    .tabs-inner {\n      position: relative;\n\n      flex: 1;\n\n      contain: layout size style;\n    }`]\n  })], IonTabs);\n  return IonTabs;\n})();\nlet IonBackButtonDelegate = /*#__PURE__*/(() => {\n  let IonBackButtonDelegate = class IonBackButtonDelegate {\n    constructor(routerOutlet, navCtrl, config) {\n      this.routerOutlet = routerOutlet;\n      this.navCtrl = navCtrl;\n      this.config = config;\n    }\n    /**\n     * @internal\n     */\n    onClick(ev) {\n      const defaultHref = this.defaultHref || this.config.get('backButtonDefaultHref');\n      if (this.routerOutlet && this.routerOutlet.canGoBack()) {\n        this.navCtrl.setDirection('back', undefined, undefined, this.routerAnimation);\n        this.routerOutlet.pop();\n        ev.preventDefault();\n      } else if (defaultHref != null) {\n        this.navCtrl.navigateBack(defaultHref, {\n          animation: this.routerAnimation\n        });\n        ev.preventDefault();\n      }\n    }\n  };\n  __decorate([HostListener('click', ['$event'])], IonBackButtonDelegate.prototype, \"onClick\", null);\n  IonBackButtonDelegate = __decorate([Directive({\n    selector: 'ion-back-button',\n    inputs: ['defaultHref', 'routerAnimation']\n  }), __param(0, Optional())], IonBackButtonDelegate);\n  return IonBackButtonDelegate;\n})();\nlet NavDelegate = /*#__PURE__*/(() => {\n  let NavDelegate = class NavDelegate {\n    constructor(ref, resolver, injector, angularDelegate, location) {\n      this.el = ref.nativeElement;\n      ref.nativeElement.delegate = angularDelegate.create(resolver, injector, location);\n      proxyOutputs(this, this.el, ['ionNavDidChange', 'ionNavWillChange']);\n    }\n  };\n  NavDelegate = __decorate([ProxyCmp({\n    inputs: ['animated', 'animation', 'root', 'rootParams', 'swipeGesture'],\n    methods: ['push', 'insert', 'insertPages', 'pop', 'popTo', 'popToRoot', 'removeIndex', 'setRoot', 'setPages', 'getActive', 'getByIndex', 'canGoBack', 'getPrevious']\n  }), Directive({\n    selector: 'ion-nav'\n  })], NavDelegate);\n  return NavDelegate;\n})();\nlet RouterLinkDelegate = /*#__PURE__*/(() => {\n  let RouterLinkDelegate = class RouterLinkDelegate {\n    constructor(locationStrategy, navCtrl, elementRef, router, routerLink) {\n      this.locationStrategy = locationStrategy;\n      this.navCtrl = navCtrl;\n      this.elementRef = elementRef;\n      this.router = router;\n      this.routerLink = routerLink;\n      this.routerDirection = 'forward';\n    }\n    ngOnInit() {\n      this.updateTargetUrlAndHref();\n    }\n    ngOnChanges() {\n      this.updateTargetUrlAndHref();\n    }\n    ngOnDestroy() {\n      if (this.subscription) {\n        this.subscription.unsubscribe();\n      }\n    }\n    updateTargetUrlAndHref() {\n      if (this.routerLink) {\n        const href = this.locationStrategy.prepareExternalUrl(this.router.serializeUrl(this.routerLink.urlTree));\n        this.elementRef.nativeElement.href = href;\n      }\n    }\n    /**\n     * @internal\n     */\n    onClick(ev) {\n      this.navCtrl.setDirection(this.routerDirection, undefined, undefined, this.routerAnimation);\n      ev.preventDefault();\n    }\n  };\n  __decorate([HostListener('click', ['$event'])], RouterLinkDelegate.prototype, \"onClick\", null);\n  RouterLinkDelegate = __decorate([Directive({\n    selector: '[routerLink]',\n    inputs: ['routerDirection', 'routerAnimation']\n  }), __param(4, Optional())], RouterLinkDelegate);\n\n  /**\n   * @hidden\n   */\n  return RouterLinkDelegate;\n})();\nlet VirtualFooter = /*#__PURE__*/(() => {\n  let VirtualFooter = class VirtualFooter {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n  };\n  VirtualFooter = __decorate([Directive({\n    selector: '[virtualFooter]'\n  })], VirtualFooter);\n\n  /**\n   * @hidden\n   */\n  return VirtualFooter;\n})();\nlet VirtualHeader = /*#__PURE__*/(() => {\n  let VirtualHeader = class VirtualHeader {\n    constructor(templateRef) {\n      this.templateRef = templateRef;\n    }\n  };\n  VirtualHeader = __decorate([Directive({\n    selector: '[virtualHeader]'\n  })], VirtualHeader);\n\n  /**\n   * @hidden\n   */\n  return VirtualHeader;\n})();\nlet VirtualItem = /*#__PURE__*/(() => {\n  let VirtualItem = class VirtualItem {\n    constructor(templateRef, viewContainer) {\n      this.templateRef = templateRef;\n      this.viewContainer = viewContainer;\n    }\n  };\n  VirtualItem = __decorate([Directive({\n    selector: '[virtualItem]'\n  })], VirtualItem);\n  return VirtualItem;\n})();\nlet IonVirtualScroll = /*#__PURE__*/(() => {\n  let IonVirtualScroll = class IonVirtualScroll {\n    constructor(z, iterableDiffers, elementRef) {\n      this.z = z;\n      this.iterableDiffers = iterableDiffers;\n      this.refMap = new WeakMap();\n      this.el = elementRef.nativeElement;\n      this.el.nodeRender = this.nodeRender.bind(this);\n    }\n    ngOnChanges(changes) {\n      if (this.trackBy && 'items' in changes) {\n        // React on virtualScroll changes only once all inputs have been initialized\n        const value = changes['items'].currentValue;\n        if (this.differ === undefined && value != null) {\n          try {\n            this.differ = this.iterableDiffers.find(value).create(this.trackBy);\n          } catch (e) {\n            throw new Error(`Cannot find a differ supporting object '${value}'. VirtualScroll only supports binding to Iterables such as Arrays.`);\n          }\n        }\n      }\n    }\n    ngDoCheck() {\n      // and if there actually are changes\n      const changes = this.differ !== undefined && this.items ? this.differ.diff(this.items) : null;\n      if (changes === null) {\n        return;\n      }\n      // TODO: optimize\n      this.checkRange(0);\n    }\n    nodeRender(el, cell, index) {\n      return this.z.run(() => {\n        let node;\n        if (!el) {\n          node = this.itmTmp.viewContainer.createEmbeddedView(this.getComponent(cell.type), {\n            $implicit: cell.value,\n            index\n          }, index);\n          el = getElement(node);\n          this.refMap.set(el, node);\n        } else {\n          node = this.refMap.get(el);\n          const ctx = node.context;\n          ctx.$implicit = cell.value;\n          ctx.index = cell.index;\n        }\n        // run sync change detections\n        node.detectChanges();\n        return el;\n      });\n    }\n    getComponent(type) {\n      switch (type) {\n        case 'item':\n          return this.itmTmp.templateRef;\n        case 'header':\n          return this.hdrTmp.templateRef;\n        case 'footer':\n          return this.ftrTmp.templateRef;\n      }\n      throw new Error('template for virtual item was not provided');\n    }\n  };\n  __decorate([ContentChild(VirtualItem, {\n    static: false\n  })], IonVirtualScroll.prototype, \"itmTmp\", void 0);\n  __decorate([ContentChild(VirtualHeader, {\n    static: false\n  })], IonVirtualScroll.prototype, \"hdrTmp\", void 0);\n  __decorate([ContentChild(VirtualFooter, {\n    static: false\n  })], IonVirtualScroll.prototype, \"ftrTmp\", void 0);\n  IonVirtualScroll = __decorate([ProxyCmp({\n    inputs: ['approxItemHeight', 'approxHeaderHeight', 'approxFooterHeight', 'headerFn', 'footerFn', 'items', 'itemHeight', 'headerHeight', 'footerHeight'],\n    methods: ['checkEnd', 'checkRange', 'positionForItem']\n  }), Component({\n    selector: 'ion-virtual-scroll',\n    template: '<ng-content></ng-content>',\n    changeDetection: ChangeDetectionStrategy.OnPush,\n    inputs: ['approxItemHeight', 'approxHeaderHeight', 'approxFooterHeight', 'headerFn', 'footerFn', 'items', 'itemHeight', 'headerHeight', 'footerHeight', 'trackBy']\n  })], IonVirtualScroll);\n  return IonVirtualScroll;\n})();\nconst getElement = view => {\n  const rootNodes = view.rootNodes;\n  for (let i = 0; i < rootNodes.length; i++) {\n    if (rootNodes[i].nodeType === 1) {\n      return rootNodes[i];\n    }\n  }\n  throw new Error('virtual element was not created');\n};\nconst ɵ0$7 = getElement;\nclass OverlayBaseController {\n  constructor(ctrl) {\n    this.ctrl = ctrl;\n  }\n  /**\n   * Creates a new overlay\n   */\n  create(opts) {\n    // TODO: next major release opts is not optional\n    return this.ctrl.create(opts || {});\n  }\n  /**\n   * When `id` is not provided, it dismisses the top overlay.\n   */\n  dismiss(data, role, id) {\n    return this.ctrl.dismiss(data, role, id);\n  }\n  /**\n   * Returns the top overlay.\n   */\n  getTop() {\n    return this.ctrl.getTop();\n  }\n}\nlet ActionSheetController = class ActionSheetController extends OverlayBaseController {\n  constructor() {\n    super(actionSheetController);\n  }\n};\nActionSheetController.ngInjectableDef = ɵɵdefineInjectable({\n  factory: function ActionSheetController_Factory() {\n    return new ActionSheetController();\n  },\n  token: ActionSheetController,\n  providedIn: \"root\"\n});\nActionSheetController = __decorate([Injectable({\n  providedIn: 'root'\n})], ActionSheetController);\nlet AlertController = class AlertController extends OverlayBaseController {\n  constructor() {\n    super(alertController);\n  }\n};\nAlertController.ngInjectableDef = ɵɵdefineInjectable({\n  factory: function AlertController_Factory() {\n    return new AlertController();\n  },\n  token: AlertController,\n  providedIn: \"root\"\n});\nAlertController = __decorate([Injectable({\n  providedIn: 'root'\n})], AlertController);\nlet LoadingController = class LoadingController extends OverlayBaseController {\n  constructor() {\n    super(loadingController);\n  }\n};\nLoadingController.ngInjectableDef = ɵɵdefineInjectable({\n  factory: function LoadingController_Factory() {\n    return new LoadingController();\n  },\n  token: LoadingController,\n  providedIn: \"root\"\n});\nLoadingController = __decorate([Injectable({\n  providedIn: 'root'\n})], LoadingController);\nlet MenuController = class MenuController {\n  /**\n   * Programmatically open the Menu.\n   * @param [menuId]  Optionally get the menu by its id, or side.\n   * @return returns a promise when the menu is fully opened\n   */\n  open(menuId) {\n    return menuController.open(menuId);\n  }\n  /**\n   * Programmatically close the Menu. If no `menuId` is given as the first\n   * argument then it'll close any menu which is open. If a `menuId`\n   * is given then it'll close that exact menu.\n   * @param [menuId]  Optionally get the menu by its id, or side.\n   * @return returns a promise when the menu is fully closed\n   */\n  close(menuId) {\n    return menuController.close(menuId);\n  }\n  /**\n   * Toggle the menu. If it's closed, it will open, and if opened, it\n   * will close.\n   * @param [menuId]  Optionally get the menu by its id, or side.\n   * @return returns a promise when the menu has been toggled\n   */\n  toggle(menuId) {\n    return menuController.toggle(menuId);\n  }\n  /**\n   * Used to enable or disable a menu. For example, there could be multiple\n   * left menus, but only one of them should be able to be opened at the same\n   * time. If there are multiple menus on the same side, then enabling one menu\n   * will also automatically disable all the others that are on the same side.\n   * @param [menuId]  Optionally get the menu by its id, or side.\n   * @return Returns the instance of the menu, which is useful for chaining.\n   */\n  enable(shouldEnable, menuId) {\n    return menuController.enable(shouldEnable, menuId);\n  }\n  /**\n   * Used to enable or disable the ability to swipe open the menu.\n   * @param shouldEnable  True if it should be swipe-able, false if not.\n   * @param [menuId]  Optionally get the menu by its id, or side.\n   * @return Returns the instance of the menu, which is useful for chaining.\n   */\n  swipeGesture(shouldEnable, menuId) {\n    return menuController.swipeGesture(shouldEnable, menuId);\n  }\n  /**\n   * @param [menuId] Optionally get the menu by its id, or side.\n   * @return Returns true if the specified menu is currently open, otherwise false.\n   * If the menuId is not specified, it returns true if ANY menu is currenly open.\n   */\n  isOpen(menuId) {\n    return menuController.isOpen(menuId);\n  }\n  /**\n   * @param [menuId]  Optionally get the menu by its id, or side.\n   * @return Returns true if the menu is currently enabled, otherwise false.\n   */\n  isEnabled(menuId) {\n    return menuController.isEnabled(menuId);\n  }\n  /**\n   * Used to get a menu instance. If a `menuId` is not provided then it'll\n   * return the first menu found. If a `menuId` is `left` or `right`, then\n   * it'll return the enabled menu on that side. Otherwise, if a `menuId` is\n   * provided, then it'll try to find the menu using the menu's `id`\n   * property. If a menu is not found then it'll return `null`.\n   * @param [menuId]  Optionally get the menu by its id, or side.\n   * @return Returns the instance of the menu if found, otherwise `null`.\n   */\n  get(menuId) {\n    return menuController.get(menuId);\n  }\n  /**\n   * @return Returns the instance of the menu already opened, otherwise `null`.\n   */\n  getOpen() {\n    return menuController.getOpen();\n  }\n  /**\n   * @return Returns an array of all menu instances.\n   */\n  getMenus() {\n    return menuController.getMenus();\n  }\n};\nMenuController.ngInjectableDef = ɵɵdefineInjectable({\n  factory: function MenuController_Factory() {\n    return new MenuController();\n  },\n  token: MenuController,\n  providedIn: \"root\"\n});\nMenuController = __decorate([Injectable({\n  providedIn: 'root'\n})], MenuController);\nlet PickerController = class PickerController extends OverlayBaseController {\n  constructor() {\n    super(pickerController);\n  }\n};\nPickerController.ngInjectableDef = ɵɵdefineInjectable({\n  factory: function PickerController_Factory() {\n    return new PickerController();\n  },\n  token: PickerController,\n  providedIn: \"root\"\n});\nPickerController = __decorate([Injectable({\n  providedIn: 'root'\n})], PickerController);\nlet ModalController = /*#__PURE__*/(() => {\n  let ModalController = class ModalController extends OverlayBaseController {\n    constructor(angularDelegate, resolver, injector) {\n      super(modalController);\n      this.angularDelegate = angularDelegate;\n      this.resolver = resolver;\n      this.injector = injector;\n    }\n    create(opts) {\n      return super.create(Object.assign({}, opts, {\n        delegate: this.angularDelegate.create(this.resolver, this.injector)\n      }));\n    }\n  };\n  ModalController = __decorate([Injectable()], ModalController);\n  return ModalController;\n})();\nlet PopoverController = /*#__PURE__*/(() => {\n  let PopoverController = class PopoverController extends OverlayBaseController {\n    constructor(angularDelegate, resolver, injector) {\n      super(popoverController);\n      this.angularDelegate = angularDelegate;\n      this.resolver = resolver;\n      this.injector = injector;\n    }\n    create(opts) {\n      return super.create(Object.assign({}, opts, {\n        delegate: this.angularDelegate.create(this.resolver, this.injector)\n      }));\n    }\n  };\n  PopoverController = __decorate([Injectable()], PopoverController);\n  return PopoverController;\n})();\nlet ToastController = class ToastController extends OverlayBaseController {\n  constructor() {\n    super(toastController);\n  }\n};\nToastController.ngInjectableDef = ɵɵdefineInjectable({\n  factory: function ToastController_Factory() {\n    return new ToastController();\n  },\n  token: ToastController,\n  providedIn: \"root\"\n});\nToastController = __decorate([Injectable({\n  providedIn: 'root'\n})], ToastController);\nlet DomController = class DomController {\n  /**\n   * Schedules a task to run during the READ phase of the next frame.\n   * This task should only read the DOM, but never modify it.\n   */\n  read(cb) {\n    getQueue().read(cb);\n  }\n  /**\n   * Schedules a task to run during the WRITE phase of the next frame.\n   * This task should write the DOM, but never READ it.\n   */\n  write(cb) {\n    getQueue().write(cb);\n  }\n};\nDomController.ngInjectableDef = ɵɵdefineInjectable({\n  factory: function DomController_Factory() {\n    return new DomController();\n  },\n  token: DomController,\n  providedIn: \"root\"\n});\nDomController = __decorate([Injectable({\n  providedIn: 'root'\n})], DomController);\nconst getQueue = () => {\n  const win = typeof window !== 'undefined' ? window : null;\n  if (win != null) {\n    const Ionic = win.Ionic;\n    if (Ionic && Ionic.queue) {\n      return Ionic.queue;\n    }\n    return {\n      read: cb => win.requestAnimationFrame(cb),\n      write: cb => win.requestAnimationFrame(cb)\n    };\n  }\n  return {\n    read: cb => cb(),\n    write: cb => cb()\n  };\n};\nconst ɵ0$8 = getQueue;\nlet AnimationController = class AnimationController {\n  /**\n   * Create a new animation\n   */\n  create(animationId) {\n    return createAnimation(animationId);\n  }\n  /**\n   * EXPERIMENTAL\n   *\n   * Given a progression and a cubic bezier function,\n   * this utility returns the time value(s) at which the\n   * cubic bezier reaches the given time progression.\n   *\n   * If the cubic bezier never reaches the progression\n   * the result will be an empty array.\n   *\n   * This is most useful for switching between easing curves\n   * when doing a gesture animation (i.e. going from linear easing\n   * during a drag, to another easing when `progressEnd` is called)\n   */\n  easingTime(p0, p1, p2, p3, progression) {\n    return getTimeGivenProgression(p0, p1, p2, p3, progression);\n  }\n};\nAnimationController.ngInjectableDef = ɵɵdefineInjectable({\n  factory: function AnimationController_Factory() {\n    return new AnimationController();\n  },\n  token: AnimationController,\n  providedIn: \"root\"\n});\nAnimationController = __decorate([Injectable({\n  providedIn: 'root'\n})], AnimationController);\nlet GestureController = class GestureController {\n  constructor(zone) {\n    this.zone = zone;\n  }\n  /**\n   * Create a new gesture\n   */\n  create(opts, runInsideAngularZone = false) {\n    if (runInsideAngularZone) {\n      Object.getOwnPropertyNames(opts).forEach(key => {\n        if (typeof opts[key] === 'function') {\n          const fn = opts[key];\n          opts[key] = (...props) => this.zone.run(() => fn(...props));\n        }\n      });\n    }\n    return createGesture(opts);\n  }\n};\nGestureController.ngInjectableDef = ɵɵdefineInjectable({\n  factory: function GestureController_Factory() {\n    return new GestureController(ɵɵinject(NgZone));\n  },\n  token: GestureController,\n  providedIn: \"root\"\n});\nGestureController = __decorate([Injectable({\n  providedIn: 'root'\n})], GestureController);\nclass IonicRouteStrategy {\n  shouldDetach(_route) {\n    return false;\n  }\n  shouldAttach(_route) {\n    return false;\n  }\n  store(_route, _detachedTree) {\n    return;\n  }\n  retrieve(_route) {\n    return null;\n  }\n  shouldReuseRoute(future, curr) {\n    if (future.routeConfig !== curr.routeConfig) {\n      return false;\n    }\n    // checking router params\n    const futureParams = future.params;\n    const currentParams = curr.params;\n    const keysA = Object.keys(futureParams);\n    const keysB = Object.keys(currentParams);\n    if (keysA.length !== keysB.length) {\n      return false;\n    }\n    // Test for A's keys different from B.\n    for (const key of keysA) {\n      if (currentParams[key] !== futureParams[key]) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\nlet didInitialize = false;\nconst appInitialize = (config, doc, zone) => {\n  return () => {\n    const win = doc.defaultView;\n    if (win && typeof window !== 'undefined') {\n      if (didInitialize) {\n        console.warn('Ionic Angular was already initialized. Make sure IonicModule.forRoot() is just called once.');\n      }\n      didInitialize = true;\n      const Ionic = win.Ionic = win.Ionic || {};\n      Ionic.config = Object.assign({}, config, {\n        _zoneGate: h => zone.run(h)\n      });\n      const aelFn = '__zone_symbol__addEventListener' in doc.body ? '__zone_symbol__addEventListener' : 'addEventListener';\n      return applyPolyfills().then(() => {\n        return defineCustomElements(win, {\n          exclude: ['ion-tabs', 'ion-tab'],\n          syncQueue: true,\n          raf,\n          jmp: h => zone.runOutsideAngular(h),\n          ael(elm, eventName, cb, opts) {\n            elm[aelFn](eventName, cb, opts);\n          },\n          rel(elm, eventName, cb, opts) {\n            elm.removeEventListener(eventName, cb, opts);\n          }\n        });\n      });\n    }\n  };\n};\nvar IonicModule_1;\nconst DECLARATIONS = [\n// proxies\nIonApp, IonAvatar, IonBackButton, IonBackdrop, IonBadge, IonButton, IonButtons, IonCard, IonCardContent, IonCardHeader, IonCardSubtitle, IonCardTitle, IonCheckbox, IonChip, IonCol, IonContent, IonDatetime, IonFab, IonFabButton, IonFabList, IonFooter, IonGrid, IonHeader, IonIcon, IonImg, IonInfiniteScroll, IonInfiniteScrollContent, IonInput, IonItem, IonItemDivider, IonItemGroup, IonItemOption, IonItemOptions, IonItemSliding, IonLabel, IonList, IonListHeader, IonMenu, IonMenuButton, IonMenuToggle, IonNav, IonNavLink, IonNote, IonProgressBar, IonRadio, IonRadioGroup, IonRange, IonRefresher, IonRefresherContent, IonReorder, IonReorderGroup, IonRippleEffect, IonRow, IonSearchbar, IonSegment, IonSegmentButton, IonSelect, IonSelectOption, IonSkeletonText, IonSlide, IonSlides, IonSpinner, IonSplitPane, IonTabBar, IonTabButton, IonText, IonTextarea, IonThumbnail, IonToggle, IonToolbar, IonTitle, IonTabs,\n// ngModel accessors\nBooleanValueAccessor, NumericValueAccessor, RadioValueAccessor, SelectValueAccessor, TextValueAccessor,\n// navigation\nIonRouterOutlet, IonBackButtonDelegate, NavDelegate, RouterLinkDelegate,\n// virtual scroll\nVirtualFooter, VirtualHeader, VirtualItem, IonVirtualScroll];\nlet IonicModule = IonicModule_1 = class IonicModule {\n  static forRoot(config) {\n    return {\n      ngModule: IonicModule_1,\n      providers: [{\n        provide: ConfigToken,\n        useValue: config\n      }, {\n        provide: APP_INITIALIZER,\n        useFactory: appInitialize,\n        multi: true,\n        deps: [ConfigToken, DOCUMENT, NgZone]\n      }]\n    };\n  }\n};\nIonicModule = IonicModule_1 = __decorate([NgModule({\n  declarations: DECLARATIONS,\n  exports: DECLARATIONS,\n  providers: [AngularDelegate, ModalController, PopoverController],\n  imports: [CommonModule]\n})], IonicModule);\n\n// DIRECTIVES\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { ActionSheetController, AlertController, AngularDelegate, AnimationController, BooleanValueAccessor, Config, DomController, GestureController, IonApp, IonAvatar, IonBackButton, IonBackButtonDelegate, IonBackdrop, IonBadge, IonButton, IonButtons, IonCard, IonCardContent, IonCardHeader, IonCardSubtitle, IonCardTitle, IonCheckbox, IonChip, IonCol, IonContent, IonDatetime, IonFab, IonFabButton, IonFabList, IonFooter, IonGrid, IonHeader, IonIcon, IonImg, IonInfiniteScroll, IonInfiniteScrollContent, IonInput, IonItem, IonItemDivider, IonItemGroup, IonItemOption, IonItemOptions, IonItemSliding, IonLabel, IonList, IonListHeader, IonMenu, IonMenuButton, IonMenuToggle, IonNav, IonNavLink, IonNote, IonProgressBar, IonRadio, IonRadioGroup, IonRange, IonRefresher, IonRefresherContent, IonReorder, IonReorderGroup, IonRippleEffect, IonRouterOutlet, IonRow, IonSearchbar, IonSegment, IonSegmentButton, IonSelect, IonSelectOption, IonSkeletonText, IonSlide, IonSlides, IonSpinner, IonSplitPane, IonTabBar, IonTabButton, IonTabs, IonText, IonTextarea, IonThumbnail, IonTitle, IonToggle, IonToolbar, IonVirtualScroll, IonicModule, IonicRouteStrategy, LoadingController, MenuController, ModalController, NavController, NavDelegate, NavParams, NumericValueAccessor, PickerController, Platform, PopoverController, RadioValueAccessor, RouterLinkDelegate, SelectValueAccessor, TextValueAccessor, ToastController, VirtualFooter, VirtualHeader, VirtualItem, ConfigToken as ɵa, ValueAccessor as ɵb, ProxyCmp as ɵc, OverlayBaseController as ɵe, appInitialize as ɵf };\n//# sourceMappingURL=ionic-angular.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}